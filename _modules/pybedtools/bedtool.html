<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pybedtools.bedtool &#8212; pybedtools 0.11.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../../_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=27fed22d" />
    <script src="../../_static/documentation_options.js?v=f3b36f1a"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for pybedtools.bedtool</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tempfile</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">textwrap</span><span class="w"> </span><span class="kn">import</span> <span class="n">dedent</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">shutil</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">subprocess</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">operator</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">random</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">string</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pprint</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">islice</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">multiprocessing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Pool</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">gzip</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">TYPE_CHECKING</span><span class="p">,</span> <span class="n">cast</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pysam</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">warnings</span><span class="w"> </span><span class="kn">import</span> <span class="n">warn</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pathlib</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Path</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.helpers</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">get_tempdir</span><span class="p">,</span>
    <span class="n">_tags</span><span class="p">,</span>
    <span class="n">call_bedtools</span><span class="p">,</span>
    <span class="n">_flatten_list</span><span class="p">,</span>
    <span class="n">_check_sequence_stderr</span><span class="p">,</span>
    <span class="n">isBAM</span><span class="p">,</span>
    <span class="n">isBGZIP</span><span class="p">,</span>
    <span class="n">isGZIP</span><span class="p">,</span>
    <span class="n">BEDToolsError</span><span class="p">,</span>
    <span class="n">pybedtoolsError</span><span class="p">,</span>
    <span class="n">_call_randomintersect</span><span class="p">,</span>
    <span class="n">SplitOutput</span><span class="p">,</span>
    <span class="n">FisherOutput</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">helpers</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.cbedtools</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">IntervalFile</span><span class="p">,</span>
    <span class="n">IntervalIterator</span><span class="p">,</span>
    <span class="n">Interval</span><span class="p">,</span>
    <span class="n">create_interval_from_list</span><span class="p">,</span>
    <span class="n">BedToolsFileError</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pybedtools</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">settings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">filenames</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.colors</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">mcolors</span>

<span class="n">_implicit_registry</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">_other_registry</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">_bam_registry</span> <span class="o">=</span> <span class="p">{}</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_jaccard_output_to_dict</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    jaccard method doesn&#39;t return an interval file, rather, it returns a short</span>
<span class="sd">    summary of results.  Here, we simply parse it into a dict for convenience.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">_s</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s2">&quot;next&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s2">&quot;__next__&quot;</span><span class="p">):</span>
        <span class="n">_s</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">s</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unexpected object </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">s</span><span class="p">)</span>
    <span class="n">header</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="n">_s</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
    <span class="n">header</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">data</span><span class="p">)))</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_reldist_output_handler</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    reldist, if called with -detail, returns a valid BED file with the relative</span>
<span class="sd">    distance as the last field.  In that case, return the BedTool immediately.</span>
<span class="sd">    If not -detail, then the results are a table, in which case here we parse</span>
<span class="sd">    into a dict for convenience.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s2">&quot;detail&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">BedTool</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">iterable</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s2">&quot;next&quot;</span><span class="p">):</span>
        <span class="n">iterable</span> <span class="o">=</span> <span class="n">s</span>
    <span class="n">header</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">header</span><span class="p">:</span>
        <span class="n">results</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="n">reldist</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">total</span><span class="p">,</span> <span class="n">fraction</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">reldist</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">count</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">total</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">fraction</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">h</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
            <span class="n">results</span><span class="p">[</span><span class="n">h</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">results</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_wraps</span><span class="p">(</span>
    <span class="n">prog</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">implicit</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">bam</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">other</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">uses_genome</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">make_tempfile_for</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">check_stderr</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">add_to_bedtool</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">nonbam</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;ALL&quot;</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">force_bam</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">genome_none_if</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">genome_if</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">genome_ok_if</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">does_not_return_bedtool</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">]</span> <span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">arg_order</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Do-it-all wrapper, to be used as a decorator.</span>

<span class="sd">    *prog* is the name of the BEDTools program that will be called.  The help</span>
<span class="sd">    for this program will also be added to the decorated method&#39;s docstring.</span>

<span class="sd">    *implicit* is the BEDTools program arg that should be filled in</span>
<span class="sd">    automatically.</span>

<span class="sd">    *bam* will disable the implicit substitution if *bam* is in the kwargs.</span>
<span class="sd">    This is typically &#39;abam&#39; or &#39;ibam&#39; if the program accepts BAM input.</span>

<span class="sd">    *other* is the BEDTools program arg that is passed in as the second input,</span>
<span class="sd">    if supported.  Within the semantics of BEDTools, the typical case will be</span>
<span class="sd">    that if implicit=&#39;a&#39; then other=&#39;b&#39;; if implicit=&#39;i&#39; then other=None.</span>

<span class="sd">    *uses_genome*, if True, will check for &#39;g&#39; and/or &#39;genome&#39; args and</span>
<span class="sd">    retrieve the corresponding genome files as needed.</span>

<span class="sd">    *make_tempfile_for* is used for the sequence methods and indicates which</span>
<span class="sd">    kwarg should have a tempfile made for it if it&#39;s not provided (&#39;fo&#39; for the</span>
<span class="sd">    sequence methods)</span>

<span class="sd">    *check_stderr*, if not None, is a function that accepts a string (which</span>
<span class="sd">    will be anything written to stdout when calling the wrapped program).  This</span>
<span class="sd">    function should return True if the string is OK, and False if it should</span>
<span class="sd">    truly be considered an error.  This is needed for wrapping fastaFromBed,</span>
<span class="sd">    which will report to stderr that it&#39;s creating an index file.</span>

<span class="sd">    *add_to_bedtool* is used for sequence methods.  It is a dictionary mapping</span>
<span class="sd">    kwargs to attributes to be created in the resulting BedTool.  Typically it</span>
<span class="sd">    is {&#39;fo&#39;:&#39;seqfn&#39;} which will add the resulting sequence name to the</span>
<span class="sd">    BedTool&#39;s .seqfn attribute. If *add_to_bedtool* is not None, then the</span>
<span class="sd">    returned BedTool will be *self* with the added attribute.  If a key is</span>
<span class="sd">    &quot;stdout&quot; (e.g., {&quot;stdout&quot;: attr_name}), then save the stdout of the command</span>
<span class="sd">    as a tempfile and store the tempfile&#39;s name in the attribute.  This is</span>
<span class="sd">    required for linksBed and bedToIgv.</span>

<span class="sd">    *nonbam* is a kwarg that even if the input file was a BAM, the output will</span>
<span class="sd">    *not* be BAM format.  For example, the `-bed` arg for intersectBed will</span>
<span class="sd">    cause the output to be in BED format, not BAM.  If not None, this can be a</span>
<span class="sd">    string, a list of strings, or the special string &quot;ALL&quot;, which means that</span>
<span class="sd">    the wrapped program will never return BAM output.</span>

<span class="sd">    *force_bam*, if True, will force the output to be BAM.  This is used for</span>
<span class="sd">    bedToBam.</span>

<span class="sd">    *genome_none_if* is a list of arguments that will ignore the requirement</span>
<span class="sd">    for a genome.  This is needed for window_maker, where -b and -g are</span>
<span class="sd">    mutually exclusive.</span>

<span class="sd">    *genome_ok_if* is a list of arguments that, if they are in</span>
<span class="sd">    *genome_none_if*, are still OK to pass in.  This is needed for bedtool</span>
<span class="sd">    genomecov, where -g is not needed if -ibam is specified...but it&#39;s still OK</span>
<span class="sd">    if the user passes a genome arg.</span>

<span class="sd">    *genome_if* is a list of arguments that will trigger the requirement for</span>
<span class="sd">    a genome; otherwise no genome needs to be specified.</span>

<span class="sd">    *does_not_return_bedtool*, if not None, should be a function that handles</span>
<span class="sd">    the returned output.  Its signature should be ``func(output, kwargs)``,</span>
<span class="sd">    where `output` is the output from the [possibly streaming] call to BEDTools</span>
<span class="sd">    and `kwargs` are passed verbatim from the wrapped method call. Some</span>
<span class="sd">    examples of methods that use this are jaccard, reldist, fisher, and split</span>
<span class="sd">    methods.</span>

<span class="sd">    *arg_order*, if not None, is a sorted list of arguments. This is used by</span>
<span class="sd">    handle_kwargs() to deal with things like issues 81 and 345, where some</span>
<span class="sd">    BEDTools programs are sensitive to argument order.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># NOTE: We are calling each BEDTools program to get its help and adding</span>
    <span class="c1"># that to the docstring of each method. This is run at import time. However</span>
    <span class="c1"># if BEDTools is not on the path at import time, `not_implemented` is set</span>
    <span class="c1"># to True and isn&#39;t reset later until the module is reloaded.</span>
    <span class="c1">#</span>
    <span class="c1"># helpers.set_bedtools_path therefore will trigger a module reload.</span>
    <span class="n">not_implemented</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># Call the program with -h to get help, which prints to stderr.</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">Popen</span><span class="p">(</span>
            <span class="n">helpers</span><span class="o">.</span><span class="n">_version_2_15_plus_names</span><span class="p">(</span><span class="n">prog</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;-h&quot;</span><span class="p">],</span>
            <span class="n">stdout</span><span class="o">=</span><span class="n">subprocess</span><span class="o">.</span><span class="n">PIPE</span><span class="p">,</span>
            <span class="n">stderr</span><span class="o">=</span><span class="n">subprocess</span><span class="o">.</span><span class="n">PIPE</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">help_str</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">communicate</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>

        <span class="c1"># underscores throw off ReStructuredText syntax of docstrings, so</span>
        <span class="c1"># replace &#39;em</span>
        <span class="n">help_str</span> <span class="o">=</span> <span class="n">help_str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="s2">&quot;**&quot;</span><span class="p">)</span>

        <span class="c1"># indent</span>
        <span class="n">help_str</span> <span class="o">=</span> <span class="n">help_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">help_str</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">**Original BEDTools help:**::&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">help_str</span><span class="p">]</span>
        <span class="n">help_str</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">help_str</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

    <span class="c1"># If the program can&#39;t be found, then we&#39;ll eventually replace the method</span>
    <span class="c1"># with a version that does nothing but raise a NotImplementedError (plus</span>
    <span class="c1"># a helpful message).</span>
    <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
        <span class="n">help_str</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s1">&#39;&quot;</span><span class="si">%s</span><span class="s1">&quot; does not appear to be installed &#39;</span>
            <span class="s2">&quot;or on the path, so this method is &quot;</span>
            <span class="s2">&quot;disabled.  Please install a more recent &quot;</span>
            <span class="s2">&quot;version of BEDTools and re-import to &quot;</span>
            <span class="s2">&quot;use this method.&quot;</span> <span class="o">%</span> <span class="n">prog</span>
        <span class="p">)</span>
        <span class="n">not_implemented</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Accepts a function to be wrapped; discards the original and returns a</span>
<span class="sd">        new, rebuilt-from-scratch function based on the kwargs passed to</span>
<span class="sd">        _wraps().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Register the implicit (as well as bam and other) args in the global</span>
        <span class="c1"># registry.  BedTool.handle_kwargs() will access these at runtime.  The</span>
        <span class="c1"># registry is keyed by program name (like intersectBed).</span>
        <span class="n">_implicit_registry</span><span class="p">[</span><span class="n">prog</span><span class="p">]</span> <span class="o">=</span> <span class="n">implicit</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_other_registry</span><span class="p">[</span><span class="n">prog</span><span class="p">]</span> <span class="o">=</span> <span class="n">other</span>
        <span class="k">if</span> <span class="n">bam</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_bam_registry</span><span class="p">[</span><span class="n">prog</span><span class="p">]</span> <span class="o">=</span> <span class="n">bam</span>

        <span class="c1"># Here&#39;s where we replace an unable-to-be-found program&#39;s method with</span>
        <span class="c1"># one that only returns a NotImplementedError</span>
        <span class="k">if</span> <span class="n">not_implemented</span><span class="p">:</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">not_implemented_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">help_str</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">not_implemented_func</span>

        <span class="n">_add_doc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">implicit</span><span class="p">:</span>
            <span class="n">_add_doc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">dedent</span><span class="p">(</span>
<span class="w">                    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                    For convenience, the file or stream this BedTool points to</span>
<span class="sd">                    is implicitly passed as the `-%s` argument to `%s`</span>
<span class="sd">                &quot;&quot;&quot;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="n">implicit</span><span class="p">,</span> <span class="n">prog</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">uses_genome</span><span class="p">:</span>
            <span class="n">_add_doc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">dedent</span><span class="p">(</span>
<span class="w">                    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                    There are two alternatives for supplying a genome.  Use</span>
<span class="sd">                    `g=&quot;genome.filename&quot;` if you have a genome&#39;s chrom sizes</span>
<span class="sd">                    saved as a file. This is the what BEDTools expects when</span>
<span class="sd">                    using it from the command line. Alternatively, use the</span>
<span class="sd">                    `genome=&quot;assembly.name&quot;` (for example, `genome=&quot;hg19&quot;`) to</span>
<span class="sd">                    use chrom sizes for that assembly without having to manage</span>
<span class="sd">                    a separate file.  The `genome` argument triggers a call</span>
<span class="sd">                    `pybedtools.chromsizes`, so see that method for more</span>
<span class="sd">                    details.</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">wrapped</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            A newly created function that will be returned by the _wraps()</span>
<span class="sd">            decorator</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="c1"># Only one non-keyword argument is supported; this is then assumed</span>
            <span class="c1"># to be &quot;other&quot; (e.g., `-b` for intersectBed)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">other</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Add the implicit values to kwargs.  If the current BedTool is</span>
            <span class="c1"># BAM, it will automatically be passed to the appropriate</span>
            <span class="c1"># BAM-support arg (like `-abam`).  But this also allows the user to</span>
            <span class="c1"># explicitly specify the abam kwarg, which will override the</span>
            <span class="c1"># auto-substitution.</span>
            <span class="c1"># Note: here, `implicit` is something like &quot;a&quot;; `bam` is something</span>
            <span class="c1"># like &quot;abam&quot;</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">implicit</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)</span>
                <span class="ow">and</span> <span class="p">(</span><span class="n">bam</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)</span>
                <span class="ow">and</span> <span class="p">(</span><span class="n">implicit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isbam</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="n">implicit</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fn</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># It is a bam file.  If this program supports BAM as the</span>
                    <span class="c1"># first input, then we set it here</span>
                    <span class="k">if</span> <span class="n">bam</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">kwargs</span><span class="p">[</span><span class="n">bam</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fn</span>

                    <span class="c1"># Otherwise, BEDTools can&#39;t currently handle it, so raise</span>
                    <span class="c1"># an exception.</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">pybedtoolsError</span><span class="p">(</span>
                            <span class="s1">&#39;&quot;</span><span class="si">%s</span><span class="s1">&quot; currently can</span><span class="se">\&#39;</span><span class="s1">t handle BAM &#39;</span>
                            <span class="s2">&quot;input, please use bam_to_bed() first.&quot;</span> <span class="o">%</span> <span class="n">prog</span>
                        <span class="p">)</span>

            <span class="c1"># Should this function handle genome files?</span>
            <span class="n">check_for_genome</span> <span class="o">=</span> <span class="n">uses_genome</span>
            <span class="k">if</span> <span class="n">uses_genome</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">genome_none_if</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">genome_none_if</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">==</span> <span class="n">implicit</span><span class="p">:</span>
                            <span class="n">check_for_genome</span> <span class="o">=</span> <span class="kc">False</span>

                    <span class="c1"># for genomecov, if -ibam then -g is optional.  So it&#39;s OK</span>
                    <span class="c1"># for the user to provide genome or g kwargs, even if</span>
                    <span class="c1"># -ibam.</span>
                    <span class="k">if</span> <span class="n">genome_ok_if</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">genome_ok_if</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">==</span> <span class="n">implicit</span><span class="p">:</span>
                                <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;g&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="s2">&quot;genome&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">):</span>
                                    <span class="n">check_for_genome</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">genome_if</span><span class="p">:</span>
                    <span class="n">check_for_genome</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">genome_if</span><span class="p">:</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">implicit</span><span class="p">):</span>
                            <span class="n">check_for_genome</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">check_for_genome</span><span class="p">:</span>
                <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_genome</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="c1"># For sequence methods, we may need to make a tempfile that will</span>
            <span class="c1"># hold the resulting sequence.  For example, fastaFromBed needs to</span>
            <span class="c1"># make a tempfile for &#39;fo&#39; if no &#39;fo&#39; was explicitly specified by</span>
            <span class="c1"># the user.</span>
            <span class="k">if</span> <span class="n">make_tempfile_for</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">make_tempfile_for</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="n">make_tempfile_for</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmp</span><span class="p">()</span>

            <span class="c1"># At runtime, this will parse the kwargs, convert streams to</span>
            <span class="c1"># tempfiles if needed, and return all the goodies</span>
            <span class="n">cmds</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">stdin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_kwargs</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="n">prog</span><span class="p">,</span>
                                                  <span class="n">arg_order</span><span class="o">=</span><span class="n">arg_order</span><span class="p">,</span>
                                                  <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="c1"># Decide whether the output is BAM format or not.</span>
            <span class="n">result_is_bam</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># By default, if the current BedTool is BAM, then the result should</span>
            <span class="c1"># be, too.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isbam</span><span class="p">:</span>
                <span class="n">result_is_bam</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># If nonbam is &quot;ALL&quot;, then this method will never return BAM</span>
            <span class="c1"># output.</span>
            <span class="k">if</span> <span class="n">nonbam</span> <span class="o">==</span> <span class="s2">&quot;ALL&quot;</span><span class="p">:</span>
                <span class="n">result_is_bam</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># If any of the `nonbam` args are found in kwargs, then result is</span>
            <span class="c1"># not a BAM.  Side note: the _nonbam name mangling is necessary to</span>
            <span class="c1"># keep the nonbam arg passed into the original _wraps() decorator</span>
            <span class="c1"># in scope.</span>
            <span class="k">if</span> <span class="n">nonbam</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">nonbam</span> <span class="o">!=</span> <span class="s2">&quot;ALL&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nonbam</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">_nonbam</span> <span class="o">=</span> <span class="p">[</span><span class="n">nonbam</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_nonbam</span> <span class="o">=</span> <span class="n">nonbam</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">_nonbam</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                        <span class="n">result_is_bam</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">break</span>

            <span class="k">if</span> <span class="n">force_bam</span><span class="p">:</span>
                <span class="n">result_is_bam</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="n">decode_output</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">result_is_bam</span>

            <span class="c1"># Do the actual call</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="n">call_bedtools</span><span class="p">(</span>
                <span class="n">cmds</span><span class="p">,</span>
                <span class="n">tmp</span><span class="p">,</span>
                <span class="n">stdin</span><span class="o">=</span><span class="n">stdin</span><span class="p">,</span>
                <span class="n">check_stderr</span><span class="o">=</span><span class="n">check_stderr</span><span class="p">,</span>
                <span class="n">decode_output</span><span class="o">=</span><span class="n">decode_output</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">does_not_return_bedtool</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">does_not_return_bedtool</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="c1"># Post-hoc editing of the BedTool -- for example, this is used for</span>
            <span class="c1"># the sequence methods to add a `seqfn` attribute to the resulting</span>
            <span class="c1"># BedTool.</span>
            <span class="k">if</span> <span class="n">add_to_bedtool</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">kw</span><span class="p">,</span> <span class="n">attr</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">add_to_bedtool</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                    <span class="k">if</span> <span class="n">kw</span> <span class="o">==</span> <span class="s2">&quot;stdout&quot;</span><span class="p">:</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="n">stream</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">kw</span><span class="p">]</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">BedTool</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span>

            <span class="n">result</span><span class="o">.</span><span class="n">_isbam</span> <span class="o">=</span> <span class="n">result_is_bam</span>
            <span class="n">result</span><span class="o">.</span><span class="n">_cmds</span> <span class="o">=</span> <span class="n">cmds</span>
            <span class="k">del</span> <span class="n">kwargs</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="c1"># Now add the edited docstring (original Python docstring plus BEDTools</span>
        <span class="c1"># help) to the newly created method above</span>
        <span class="k">if</span> <span class="n">func</span><span class="o">.</span><span class="vm">__doc__</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">orig</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">orig</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="vm">__doc__</span>

        <span class="n">wrapped</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">orig</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_add_doc</span><span class="p">)</span> <span class="o">+</span> <span class="n">help_str</span>

        <span class="c1"># Add the original method&#39;s name to a new attribute so we can access it</span>
        <span class="c1"># when logging history</span>
        <span class="n">wrapped</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span>  <span class="c1"># type: ignore</span>

        <span class="k">return</span> <span class="n">wrapped</span>

    <span class="k">return</span> <span class="n">decorator</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_log_to_history</span><span class="p">(</span><span class="n">method</span><span class="p">:</span> <span class="n">Callable</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Decorator to add a method and its kwargs to the history.</span>

<span class="sd">    Assumes that you only add this decorator to bedtool instances that</span>
<span class="sd">    return other bedtool instances</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">decorated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="c1"># this calls the actual method in the first place; *result* is</span>
        <span class="c1"># whatever you get back</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># add appropriate tags</span>
        <span class="n">parent_tag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tag</span>
        <span class="n">result_tag</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">_tag</span>

        <span class="n">history_step</span> <span class="o">=</span> <span class="n">HistoryStep</span><span class="p">(</span>
            <span class="n">method</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">parent_tag</span><span class="p">,</span> <span class="n">result_tag</span>
        <span class="p">)</span>

        <span class="c1"># only add the current history to the new bedtool if there&#39;s</span>
        <span class="c1"># something to add</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="p">)</span>

        <span class="c1"># but either way, add this history step to the result.</span>
        <span class="n">result</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">history_step</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="n">decorated</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="vm">__doc__</span>
    <span class="k">return</span> <span class="n">decorated</span>


<div class="viewcode-block" id="BedTool">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.html#pybedtools.bedtool.BedTool">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BedTool</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">TEMPFILES</span> <span class="o">=</span> <span class="n">filenames</span><span class="o">.</span><span class="n">TEMPFILES</span>

<div class="viewcode-block" id="BedTool.__init__">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.html#pybedtools.bedtool.BedTool.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">from_string</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">remote</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper around Aaron Quinlan&#39;s ``BEDtools`` suite of programs</span>
<span class="sd">        (https://github.com/arq5x/bedtools); also contains many useful</span>
<span class="sd">        methods for more detailed work with BED files.</span>

<span class="sd">        *fn* is typically the name of a BED-like file, but can also be</span>
<span class="sd">        one of the following:</span>

<span class="sd">            * a string filename</span>
<span class="sd">            * another BedTool object</span>
<span class="sd">            * an iterable of Interval objects</span>
<span class="sd">            * an open file object</span>
<span class="sd">            * a &quot;file contents&quot; string (see below)</span>

<span class="sd">        If *from_string* is True, then you can pass a string that contains</span>
<span class="sd">        the contents of the BedTool you want to create.  This will treat all</span>
<span class="sd">        spaces as TABs and write to tempfile, treating whatever you pass as</span>
<span class="sd">        *fn* as the contents of the bed file.  This also strips empty lines.</span>

<span class="sd">        Typical usage is to point to an existing file::</span>

<span class="sd">            a = BedTool(&#39;a.bed&#39;)</span>

<span class="sd">        But you can also create one from scratch from a string::</span>

<span class="sd">            &gt;&gt;&gt; s = &#39;&#39;&#39;</span>
<span class="sd">            ... chrX  1  100</span>
<span class="sd">            ... chrX 25  800</span>
<span class="sd">            ... &#39;&#39;&#39;</span>
<span class="sd">            &gt;&gt;&gt; a = BedTool(s, from_string=True)</span>

<span class="sd">        Or use examples that come with pybedtools::</span>

<span class="sd">            &gt;&gt;&gt; example_files = pybedtools.list_example_files()</span>
<span class="sd">            &gt;&gt;&gt; assert &#39;a.bed&#39; in example_files</span>
<span class="sd">            &gt;&gt;&gt; a = pybedtools.example_bedtool(&#39;a.bed&#39;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">remote</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Remote BAM no longer supported (since BEDTools does not &quot;</span> <span class="s2">&quot;support it)&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remote</span> <span class="o">=</span> <span class="n">remote</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_isbam</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bam_header</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cmds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">from_string</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">fn</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;from_string=True requires a string to parse&quot;</span><span class="p">)</span>
            <span class="n">bed_contents</span> <span class="o">=</span> <span class="n">fn</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmp</span><span class="p">()</span>
            <span class="n">fout</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">bed_contents</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">line</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">())</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="n">fout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="n">fout</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># if fn is a Path object, we have to use its string representation</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">PurePath</span><span class="p">):</span>
                <span class="n">fn</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>

            <span class="c1"># our work is already done</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">BedTool</span><span class="p">):</span>
                <span class="n">fn</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">fn</span>

            <span class="c1"># from_string=False, so assume it&#39;s a filename</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">remote</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_isbam</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;File &quot;</span><span class="si">%s</span><span class="s1">&quot; does not exist&#39;</span> <span class="o">%</span> <span class="n">fn</span>
                        <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_isbam</span> <span class="o">=</span> <span class="n">isBAM</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>

                <span class="c1"># TODO: we dont&#39; really need this, but it&#39;s added here for</span>
                <span class="c1"># compatibility with existing tests</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isbam</span><span class="p">:</span>
                    <span class="n">header</span> <span class="o">=</span> <span class="n">pysam</span><span class="o">.</span><span class="n">Samfile</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
                    <span class="c1"># For example:</span>
                    <span class="c1"># {</span>
                    <span class="c1">#     &#39;HD&#39;: {&#39;VN&#39;: &#39;1.0&#39;, &#39;SO&#39;: &#39;coordinate&#39;},</span>
                    <span class="c1">#     &#39;SQ&#39;: [</span>
                    <span class="c1">#         {&#39;LN&#39;: 23011544,</span>
                    <span class="c1">#          &#39;SN&#39;: &#39;chr2L&#39;},</span>
                    <span class="c1">#         {&#39;LN&#39;: 21146708,</span>
                    <span class="c1">#          &#39;SN&#39;: &#39;chr2R&#39;},</span>
                    <span class="c1">#         {&#39;LN&#39;: 24543557,</span>
                    <span class="c1">#          &#39;SN&#39;: &#39;chr3L&#39;},</span>
                    <span class="c1">#         {&#39;LN&#39;: 27905053,</span>
                    <span class="c1">#          &#39;SN&#39;: &#39;chr3R&#39;},</span>
                    <span class="c1">#         {&#39;LN&#39;: 1351857,</span>
                    <span class="c1">#          &#39;SN&#39;: &#39;chr4&#39;},</span>
                    <span class="c1">#         {&#39;LN&#39;: 22422827,</span>
                    <span class="c1">#          &#39;SN&#39;: &#39;chrX&#39;}</span>
                    <span class="c1">#     ]</span>
                    <span class="c1"># }</span>

                    <span class="n">txt_header</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">header</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">v</span><span class="p">:</span>
                                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                                    <span class="n">txt_header</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                        <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                                            <span class="p">[</span><span class="s2">&quot;@&quot;</span> <span class="o">+</span> <span class="n">k</span><span class="p">]</span>
                                            <span class="o">+</span> <span class="p">[</span>
                                                <span class="s2">&quot;:&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
                                                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                                            <span class="p">]</span>
                                        <span class="p">)</span>
                                    <span class="p">)</span>
                                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                                    <span class="n">txt_header</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

                        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                            <span class="n">txt_header</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                                    <span class="p">[</span><span class="s2">&quot;@&quot;</span> <span class="o">+</span> <span class="n">k</span><span class="p">]</span>
                                    <span class="o">+</span> <span class="p">[</span>
                                        <span class="s2">&quot;:&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
                                        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                                    <span class="p">]</span>
                                <span class="p">)</span>
                            <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;unhandled type in BAM header&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_bam_header</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">txt_header</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

            <span class="c1"># If tuple or list, then save as file first</span>
            <span class="c1"># (fixes #73)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="n">fn</span> <span class="o">=</span> <span class="n">BedTool</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">fn</span><span class="p">))</span><span class="o">.</span><span class="n">saveas</span><span class="p">()</span><span class="o">.</span><span class="n">fn</span>

            <span class="c1"># Otherwise assume iterator, say an open file as from</span>
            <span class="c1"># subprocess.PIPE</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fn</span> <span class="o">=</span> <span class="n">fn</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fn</span> <span class="o">=</span> <span class="n">fn</span>
        <span class="n">tag</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">ascii_lowercase</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">)])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tag</span> <span class="o">=</span> <span class="n">tag</span>
        <span class="n">_tags</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hascounts</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_file_type</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seqfn</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fastq</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">igv_script</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">links_html</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history</span> <span class="o">=</span> <span class="n">History</span><span class="p">()</span></div>


    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_dataframe</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">outfile</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sep</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="n">header</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">na_rep</span><span class="p">:</span><span class="nb">str</span> <span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span><span class="nb">bool</span> <span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a BedTool from a pandas.DataFrame.</span>

<span class="sd">        If `outfile` is None, a temporary file will be used. Otherwise it can</span>
<span class="sd">        be a specific filename or an open file handle. Additional kwargs will</span>
<span class="sd">        be passed to `pandas.DataFrame.to_csv`.</span>

<span class="sd">        The fields of the resulting BedTool will match the order of columns in</span>
<span class="sd">        the dataframe.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;pandas must be installed to use dataframes&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">outfile</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">outfile</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_tmp</span><span class="p">()</span>
        <span class="n">default_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">sep</span><span class="o">=</span><span class="n">sep</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span> <span class="n">na_rep</span><span class="o">=</span><span class="n">na_rep</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>
        <span class="n">default_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="o">**</span><span class="n">default_kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="n">outfile</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">fn</span> <span class="o">=</span> <span class="n">outfile</span><span class="o">.</span><span class="n">name</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;`outfile` is not a string and doesn&#39;t have a `name` attribute. &quot;</span>
                    <span class="s2">&quot;Unable to determine filename.&quot;</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">BedTool</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>

<div class="viewcode-block" id="BedTool.split">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.split.html#pybedtools.bedtool.BedTool.split">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Split each feature using a user-defined function.</span>

<span class="sd">        Calls the provided function `func` with each interval.  In contrast to</span>
<span class="sd">        `each` (which does something similar), this method expects `func` to</span>
<span class="sd">        return an *iterable* of Interval objects.</span>

<span class="sd">        args and kwargs are passed directly to `func`.</span>

<span class="sd">        Returns a new BedTool.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">generator</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">orig_interval</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="n">func</span><span class="p">(</span><span class="n">orig_interval</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">interval</span>

        <span class="k">return</span> <span class="n">BedTool</span><span class="p">(</span><span class="n">generator</span><span class="p">())</span></div>


<div class="viewcode-block" id="BedTool.truncate_to_chrom">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.truncate_to_chrom.html#pybedtools.bedtool.BedTool.truncate_to_chrom">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">truncate_to_chrom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">genome</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ensure all features fall within chromosome limits.</span>

<span class="sd">        Some peak-callers extend peaks such that the boundaries overstep</span>
<span class="sd">        chromosome coordinates.  Upon uploading such a file to a genome browser</span>
<span class="sd">        like UCSC, this results in an error like::</span>

<span class="sd">            Error line 101 of custom track: chromEnd larger than chrom chr2</span>
<span class="sd">            size</span>

<span class="sd">        Use this method to clean your file, truncating any out-of-bounds</span>
<span class="sd">        features to fit within the chromosome coordinates of `genome`.</span>

<span class="sd">        `genome` can be either an assembly name (&#39;dm3&#39;) or a dictionary where</span>
<span class="sd">        keys are chrom and values are (start, stop) tuples.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">genome</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">chromdict</span> <span class="o">=</span> <span class="n">genome</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">genome</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
            <span class="n">chromdict</span> <span class="o">=</span> <span class="n">helpers</span><span class="o">.</span><span class="n">chromsizes</span><span class="p">(</span><span class="n">genome</span><span class="p">)</span>

        <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmp</span><span class="p">()</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fout</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">coords</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">chromdict</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="o">=</span> <span class="n">coords</span>
                <span class="n">start</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
                <span class="n">stop</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">stop</span><span class="p">)</span>
                <span class="n">fout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">chrom</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span></div>


<div class="viewcode-block" id="BedTool.tabix_intervals">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.tabix_intervals.html#pybedtools.bedtool.BedTool.tabix_intervals">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">tabix_intervals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_or_string</span><span class="p">:</span> <span class="n">Interval</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="n">check_coordinates</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve all intervals within coordinates from a &quot;tabixed&quot; BedTool.</span>

<span class="sd">        Given either a string in &quot;chrom:start-stop&quot; format, or an interval-like</span>
<span class="sd">        object with chrom, start, stop attributes, return a *streaming* BedTool</span>
<span class="sd">        of the features in this BedTool that overlap the provided interval.</span>

<span class="sd">        If the coordinates are invalid, an empty generator is returned unless</span>
<span class="sd">        `check_coordinates=True` in which case a ValueError will be raised.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tabixed</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;This BedTool has not been indexed for tabix &quot;</span>
                <span class="s2">&quot;-- please use the .tabix() method&quot;</span>
            <span class="p">)</span>

        <span class="c1"># tabix expects 1-based coords, but BEDTools works with</span>
        <span class="c1"># zero-based. pybedtools and pysam also work with zero-based. So we can</span>
        <span class="c1"># pass zero-based directly to the pysam tabix interface.</span>
        <span class="n">tbx</span> <span class="o">=</span> <span class="n">pysam</span><span class="o">.</span><span class="n">TabixFile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">)</span>

        <span class="c1"># If an interval is passed, use its coordinates directly</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">interval_or_string</span><span class="p">,</span> <span class="n">Interval</span><span class="p">):</span>
            <span class="n">interval</span><span class="p">:</span> <span class="n">Interval</span> <span class="o">=</span> <span class="n">interval_or_string</span>
            <span class="n">chrom</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">interval</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="n">interval</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">interval</span><span class="o">.</span><span class="n">stop</span>
        <span class="c1"># Parse string directly instead of relying on Interval, in order to</span>
        <span class="c1"># permit full chromosome fetching</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">helpers</span><span class="o">.</span><span class="n">coord_re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">interval_or_string</span><span class="p">)</span>
            <span class="c1"># Assume string is contig if it doesn&#39;t fit chrom:start-end format</span>
            <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">chrom</span> <span class="o">=</span> <span class="n">interval_or_string</span>
                <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
            <span class="c1"># Otherwise parse the coordinates</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">chrom</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
                <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>

        <span class="c1"># Fetch results.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">tbx</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">chrom</span><span class="p">),</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">check_coordinates</span><span class="p">:</span>
                <span class="k">raise</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># pysam.ctabix.TabixIterator does not include newlines when yielding so</span>
        <span class="c1"># we need to add them.</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">gen</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">i</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

        <span class="c1"># xref #190</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">BedTool</span><span class="p">(</span><span class="n">gen</span><span class="p">())</span><span class="o">.</span><span class="n">saveas</span><span class="p">()</span>
        <span class="n">tbx</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">x</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">tabix_contigs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of contigs from the tabix index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tabixed</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;This BedTool has not been indexed for tabix &quot;</span>
                <span class="s2">&quot;-- please use the .tabix() method&quot;</span>
            <span class="p">)</span>

        <span class="n">tbx</span> <span class="o">=</span> <span class="n">pysam</span><span class="o">.</span><span class="n">TabixFile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tbx</span><span class="o">.</span><span class="n">contigs</span>

<div class="viewcode-block" id="BedTool.tabix">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.tabix.html#pybedtools.bedtool.BedTool.tabix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">tabix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_place</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">force</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">is_sorted</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepare a BedTool for use with Tabix.</span>

<span class="sd">        Returns a new BedTool that has been BGZIP compressed</span>
<span class="sd">        and indexed by tabix.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        in_place : bool</span>
<span class="sd">            If True (default), then assume the file is already sorted and</span>
<span class="sd">            replace the existing file with the BGZIPed version.</span>

<span class="sd">        force : bool</span>
<span class="sd">            If True (default is False), then overwrite both the index and the</span>
<span class="sd">            BGZIP file.</span>

<span class="sd">        is_sorted : bool</span>
<span class="sd">            If True (default is False), then assume the file is already sorted</span>
<span class="sd">            so that BedTool.bgzip() doesn&#39;t have to do that work.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Return quickly if nothing to do</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tabixed</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">force</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="c1"># Make sure it&#39;s BGZIPed</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bgzip</span><span class="p">(</span><span class="n">in_place</span><span class="o">=</span><span class="n">in_place</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">,</span> <span class="n">is_sorted</span><span class="o">=</span><span class="n">is_sorted</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;bam&quot;</span><span class="p">,</span> <span class="s2">&quot;empty&quot;</span><span class="p">]:</span>
            <span class="n">pysam</span><span class="o">.</span><span class="n">tabix_index</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">,</span> <span class="n">preset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">file_type</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="k">return</span> <span class="n">BedTool</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_tabixed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Verifies that we&#39;re working with a tabixed file: a string filename</span>
<span class="sd">        pointing to a BGZIPed file with a .tbi file in the same dir.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">isBGZIP</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span> <span class="o">+</span> <span class="s2">&quot;.tbi&quot;</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>

<div class="viewcode-block" id="BedTool.bgzip">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.bgzip.html#pybedtools.bedtool.BedTool.bgzip">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">bgzip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_place</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">force</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">is_sorted</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function for more control over &quot;tabixed&quot; BedTools.</span>

<span class="sd">        Checks to see if we already have a BGZIP file; if not then prepare one.</span>
<span class="sd">        Always leaves the original file alone.  You can always just make a</span>
<span class="sd">        BedTool out of an already sorted and BGZIPed file to avoid this step.</span>

<span class="sd">        `in_place` will put the BGZIPed file in the same dir (possibly after</span>
<span class="sd">        sorting to tempfile).</span>

<span class="sd">        If `is_sorted`, then assume the file is already sorted. Otherwise call</span>
<span class="sd">        bedtools sort with the `-header` option.</span>

<span class="sd">        `force` will overwrite without asking.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># It may already be BGZIPed...</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">force</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">isBGZIP</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fn</span>

        <span class="c1"># If not in_place, then make a tempfile for the BGZIPed version</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">in_place</span><span class="p">:</span>
            <span class="c1"># Get tempfile name, sorted or not</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_sorted</span><span class="p">:</span>
                <span class="n">fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">header</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">fn</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmp</span><span class="p">()</span>

            <span class="c1"># Register for later deletion</span>
            <span class="n">outfn</span> <span class="o">=</span> <span class="n">fn</span> <span class="o">+</span> <span class="s2">&quot;.gz&quot;</span>
            <span class="n">BedTool</span><span class="o">.</span><span class="n">TEMPFILES</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">outfn</span><span class="p">)</span>

            <span class="c1"># Creates tempfile.gz</span>
            <span class="n">pysam</span><span class="o">.</span><span class="n">tabix_compress</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">outfn</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">outfn</span>

        <span class="c1"># Otherwise, make sure the BGZIPed version has a similar name to the</span>
        <span class="c1"># current BedTool&#39;s file</span>
        <span class="k">if</span> <span class="n">in_place</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_sorted</span><span class="p">:</span>
                <span class="n">fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">header</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">saveas</span><span class="p">()</span><span class="o">.</span><span class="n">fn</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fn</span>
            <span class="n">outfn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fn</span> <span class="o">+</span> <span class="s2">&quot;.gz&quot;</span>
            <span class="n">pysam</span><span class="o">.</span><span class="n">tabix_compress</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">outfn</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">outfn</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">delete_temporary_history</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ask</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">raw_input_func</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use at your own risk!  This method will delete temp files. You will be</span>
<span class="sd">        prompted for deletion of files unless you specify *ask=False*.</span>

<span class="sd">        Deletes all temporary files created during the history of this BedTool</span>
<span class="sd">        up to but not including the file this current BedTool points to.</span>

<span class="sd">        Any filenames that are in the history and have the following pattern</span>
<span class="sd">        will be deleted::</span>

<span class="sd">            &lt;TEMP_DIR&gt;/pybedtools.*.tmp</span>

<span class="sd">        (where &lt;TEMP_DIR&gt; is the result from get_tempdir() and is by default</span>
<span class="sd">        &quot;/tmp&quot;)</span>

<span class="sd">        Any files that don&#39;t have this format will be left alone.</span>

<span class="sd">        (*raw_input_func* is used for testing)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flattened_history</span> <span class="o">=</span> <span class="n">_flatten_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="p">)</span>
        <span class="n">to_delete</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">tempdir</span> <span class="o">=</span> <span class="n">get_tempdir</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">flattened_history</span><span class="p">:</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">fn</span>
            <span class="k">if</span> <span class="n">fn</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">tempdir</span><span class="p">),</span> <span class="s2">&quot;pybedtools&quot;</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">fn</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.tmp&quot;</span><span class="p">):</span>
                    <span class="n">to_delete</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">raw_input_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">raw_input_func</span> <span class="o">=</span> <span class="nb">input</span>

        <span class="n">str_fns</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">to_delete</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ask</span><span class="p">:</span>
            <span class="n">answer</span> <span class="o">=</span> <span class="n">raw_input_func</span><span class="p">(</span><span class="s2">&quot;Delete these files?</span><span class="se">\n\t</span><span class="si">%s</span><span class="se">\n</span><span class="s2">(y/N) &quot;</span> <span class="o">%</span> <span class="n">str_fns</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">answer</span><span class="o">.</span><span class="n">lower</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;OK, not deleting.&quot;</span><span class="p">)</span>
                <span class="k">return</span>
        <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">to_delete</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">unlink</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
        <span class="k">return</span>

<div class="viewcode-block" id="BedTool.filter">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.filter.html#pybedtools.bedtool.BedTool.filter">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filter features by user-defined function.</span>

<span class="sd">        Takes a function *func* that is called for each feature in the</span>
<span class="sd">        `BedTool` object and returns only those for which the function returns</span>
<span class="sd">        True.</span>

<span class="sd">        *args and **kwargs are passed directly to *func*.</span>

<span class="sd">        Returns a streaming BedTool; if you want the filename then use the</span>
<span class="sd">        .saveas() method.</span>

<span class="sd">        &gt;&gt;&gt; a = pybedtools.example_bedtool(&#39;a.bed&#39;)</span>
<span class="sd">        &gt;&gt;&gt; subset = a.filter(lambda b: b.chrom == &#39;chr1&#39; and b.start &lt; 150)</span>
<span class="sd">        &gt;&gt;&gt; len(a), len(subset)</span>
<span class="sd">        (4, 2)</span>

<span class="sd">        so it has extracted 2 records from the original 4.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">BedTool</span><span class="p">((</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">func</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)))</span></div>


<div class="viewcode-block" id="BedTool.field_count">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.field_count.html#pybedtools.bedtool.BedTool.field_count">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">field_count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of fields in each line of this BedTool (checks `n` lines)</span>

<span class="sd">        Return the number of fields in the features this file contains.  Checks</span>
<span class="sd">        the first *n* features.</span>

<span class="sd">        &gt;&gt;&gt; a = pybedtools.example_bedtool(&#39;a.bed&#39;)</span>
<span class="sd">        &gt;&gt;&gt; a.field_count()</span>
<span class="sd">        6</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_type</span> <span class="o">==</span> <span class="s2">&quot;empty&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">fields</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">feat</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># TODO: make this more efficient.</span>
            <span class="n">fields</span><span class="o">.</span><span class="n">update</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">feat</span><span class="o">.</span><span class="n">fields</span><span class="p">)])</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">fields</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">fields</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="BedTool.each">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.each.html#pybedtools.bedtool.BedTool.each">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">each</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Modify each feature with a user-defined function.</span>

<span class="sd">        Applies user-defined function *func* to each feature.  *func* must</span>
<span class="sd">        accept an Interval as its first argument; *args and **kwargs will be</span>
<span class="sd">        passed to *func*.</span>

<span class="sd">        *func* must return an Interval object OR a value that evaluates to</span>
<span class="sd">        False, in which case the original feature will be removed from the</span>
<span class="sd">        output.  This way, an additional &quot;filter&quot; call is not necessary.</span>

<span class="sd">        &gt;&gt;&gt; def truncate_feature(feature, limit=0):</span>
<span class="sd">        ...     feature.score = str(len(feature))</span>
<span class="sd">        ...     if len(feature) &gt; limit:</span>
<span class="sd">        ...         feature.stop = feature.start + limit</span>
<span class="sd">        ...         feature.name = feature.name + &#39;.short&#39;</span>
<span class="sd">        ...     return feature</span>

<span class="sd">        &gt;&gt;&gt; a = pybedtools.example_bedtool(&#39;a.bed&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b = a.each(truncate_feature, limit=100)</span>
<span class="sd">        &gt;&gt;&gt; print(b) #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        chr1	1	100	feature1	99	+</span>
<span class="sd">        chr1	100	200	feature2	100	+</span>
<span class="sd">        chr1	150	250	feature3.short	350	-</span>
<span class="sd">        chr1	900	950	feature4	50	+</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_generator</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">result</span>

        <span class="k">return</span> <span class="n">BedTool</span><span class="p">(</span><span class="n">_generator</span><span class="p">())</span></div>


<div class="viewcode-block" id="BedTool.introns">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.introns.html#pybedtools.bedtool.BedTool.introns">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">introns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gene</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;gene&quot;</span><span class="p">,</span> <span class="n">exon</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;exon&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create intron features (requires specific input format).</span>

<span class="sd">        NOTE: this method assumes a simple file with non-overlapping exons. For</span>
<span class="sd">        more sophisticated features, consider the gffutils package instead.</span>

<span class="sd">        Given a BED12 or a GFF with exons, create a new `BedTool` with just</span>
<span class="sd">        introns.  The output is a bed6 file with the score column (5) being one</span>
<span class="sd">        of &#39;intron&#39;/&#39;utr5&#39;/&#39;utr3&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># iterate over all the features in the gene.</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_type</span> <span class="o">==</span> <span class="s2">&quot;gff&quot;</span><span class="p">:</span>
            <span class="n">exon_iter</span> <span class="o">=</span> <span class="n">BedTool</span><span class="p">((</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">s</span> <span class="k">if</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">exon</span><span class="p">))</span><span class="o">.</span><span class="n">saveas</span><span class="p">()</span>
            <span class="n">gene_iter</span> <span class="o">=</span> <span class="n">BedTool</span><span class="p">((</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">s</span> <span class="k">if</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">gene</span><span class="p">))</span><span class="o">.</span><span class="n">saveas</span><span class="p">()</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_type</span> <span class="o">==</span> <span class="s2">&quot;bed&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">field_count</span><span class="p">()</span> <span class="o">==</span> <span class="mi">12</span><span class="p">:</span>
                <span class="n">exon_iter</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">bed6</span><span class="p">()</span><span class="o">.</span><span class="n">saveas</span><span class="p">()</span>
                <span class="n">gene_iter</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">saveas</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># TODO: bed6. groupby on name and find smallest start,</span>
                <span class="c1"># largest stop.</span>
                <span class="n">exon_iter</span> <span class="o">=</span> <span class="n">s</span>
                <span class="n">gene_iter</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;.introns() only supported for bed12&quot;</span> <span class="s2">&quot;and GFF&quot;</span>
                <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;.introns() only supported for BED and GFF&quot;</span><span class="p">)</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">BedTool</span><span class="o">.</span><span class="n">_tmp</span><span class="p">(),</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
            <span class="c1"># group on the name.</span>
            <span class="n">exon_intervals</span> <span class="o">=</span> <span class="n">IntervalFile</span><span class="p">(</span><span class="n">exon_iter</span><span class="o">.</span><span class="n">fn</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gene_iter</span><span class="p">:</span>
                <span class="c1"># search finds all, but we just want the ones that completely</span>
                <span class="c1"># overlap this gene.</span>
                <span class="n">exons</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">e</span>
                    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">exon_intervals</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">same_strand</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">g</span><span class="o">.</span><span class="n">start</span> <span class="ow">and</span> <span class="n">e</span><span class="o">.</span><span class="n">end</span> <span class="o">&lt;=</span> <span class="n">g</span><span class="o">.</span><span class="n">end</span>
                <span class="p">]</span>

                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">exon_instance</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">exons</span><span class="p">):</span>
                    <span class="n">exon_instance</span><span class="p">:</span> <span class="n">pybedtools</span><span class="o">.</span><span class="n">Interval</span>
                    <span class="c1"># 5&#39; utr between gene start and first intron</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">exon_instance</span><span class="o">.</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">g</span><span class="o">.</span><span class="n">start</span><span class="p">:</span>
                        <span class="n">utr</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;+&quot;</span><span class="p">:</span> <span class="s2">&quot;utr5&quot;</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span> <span class="s2">&quot;utr3&quot;</span><span class="p">}[</span><span class="n">g</span><span class="o">.</span><span class="n">strand</span><span class="p">]</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="s2">&quot;</span><span class="si">%s</span><span class="se">\t</span><span class="si">%i</span><span class="se">\t</span><span class="si">%i</span><span class="se">\t</span><span class="si">%s</span><span class="se">\t</span><span class="si">%s</span><span class="se">\t</span><span class="si">%s</span><span class="s2">&quot;</span>
                            <span class="o">%</span> <span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">exon_instance</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">utr</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">strand</span><span class="p">),</span>
                            <span class="n">file</span><span class="o">=</span><span class="n">fh</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">exons</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">exon_instance</span><span class="o">.</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">g</span><span class="o">.</span><span class="n">end</span><span class="p">:</span>
                        <span class="n">utr</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;+&quot;</span><span class="p">:</span> <span class="s2">&quot;utr3&quot;</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span> <span class="s2">&quot;utr5&quot;</span><span class="p">}[</span><span class="n">g</span><span class="o">.</span><span class="n">strand</span><span class="p">]</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="s2">&quot;</span><span class="si">%s</span><span class="se">\t</span><span class="si">%i</span><span class="se">\t</span><span class="si">%i</span><span class="se">\t</span><span class="si">%s</span><span class="se">\t</span><span class="si">%s</span><span class="se">\t</span><span class="si">%s</span><span class="s2">&quot;</span>
                            <span class="o">%</span> <span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="n">exon_instance</span><span class="o">.</span><span class="n">end</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">end</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">utr</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">strand</span><span class="p">),</span>
                            <span class="n">file</span><span class="o">=</span><span class="n">fh</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="k">elif</span> <span class="n">i</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">exons</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">istart</span> <span class="o">=</span> <span class="n">exon_instance</span><span class="o">.</span><span class="n">end</span>
                        <span class="n">iend</span> <span class="o">=</span> <span class="n">exons</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">start</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="s2">&quot;</span><span class="si">%s</span><span class="se">\t</span><span class="si">%i</span><span class="se">\t</span><span class="si">%i</span><span class="se">\t</span><span class="si">%s</span><span class="se">\t</span><span class="s2">intron</span><span class="se">\t</span><span class="si">%s</span><span class="s2">&quot;</span>
                            <span class="o">%</span> <span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="n">istart</span><span class="p">,</span> <span class="n">iend</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">strand</span><span class="p">),</span>
                            <span class="n">file</span><span class="o">=</span><span class="n">fh</span><span class="p">,</span>
                        <span class="p">)</span>
        <span class="k">return</span> <span class="n">BedTool</span><span class="p">(</span><span class="n">fh</span><span class="o">.</span><span class="n">name</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">features</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterable of features</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;next&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;__next__&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="n">FileType</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;bed&#39;</span><span class="p">,</span> <span class="s1">&#39;vcf&#39;</span><span class="p">,</span> <span class="s1">&#39;gff&#39;</span><span class="p">,</span> <span class="s1">&#39;bam&#39;</span><span class="p">,</span> <span class="s1">&#39;sam&#39;</span><span class="p">,</span> <span class="s1">&#39;empty&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">file_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">FileType</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the type of the current file.  One of (&#39;bed&#39;,&#39;vcf&#39;,&#39;gff&#39;, &#39;bam&#39;,</span>
<span class="sd">        &#39;sam&#39;, &#39;empty&#39;).</span>

<span class="sd">        &gt;&gt;&gt; a = pybedtools.example_bedtool(&#39;a.bed&#39;)</span>
<span class="sd">        &gt;&gt;&gt; print(a.file_type)</span>
<span class="sd">        bed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Checking file_type not supported for &quot;</span>
                <span class="s2">&quot;non-file BedTools. Use .saveas() to &quot;</span>
                <span class="s2">&quot;save as a temp file first.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isbam</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_file_type</span> <span class="o">=</span> <span class="s2">&quot;bam&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_file_type</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span><span class="o">.</span><span class="n">file_type</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_file_type</span> <span class="o">=</span> <span class="s2">&quot;empty&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_file_type</span>

<div class="viewcode-block" id="BedTool.cut">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.cut.html#pybedtools.bedtool.BedTool.cut">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">cut</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indexes</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">stream</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Analogous to unix `cut`.</span>

<span class="sd">        Similar to unix `cut` except indexes are 0-based, must be a list</span>
<span class="sd">        and the columns are returned in the order requested.</span>

<span class="sd">        This method returns a BedTool of results, which means that the indexes</span>
<span class="sd">        returned must be valid GFF/GTF/BED/SAM features.</span>

<span class="sd">        If you would like arbitrary columns -- say, just chrom and featuretype</span>
<span class="sd">        of a GFF, which would not comprise a valid feature -- then instead of</span>
<span class="sd">        this method, simply use indexes on each feature, e.g,</span>

<span class="sd">        &gt;&gt;&gt; gff = pybedtools.example_bedtool(&#39;d.gff&#39;)</span>
<span class="sd">        &gt;&gt;&gt; results = [(f[0], f[2]) for f in gff]</span>

<span class="sd">        In addition, `indexes` can contain keys of the GFF/GTF attributes, in</span>
<span class="sd">        which case the values are returned. e.g. &#39;gene_name&#39; will return the</span>
<span class="sd">        corresponding name from a GTF, or &#39;start&#39; will return the start</span>
<span class="sd">        attribute of a BED Interval.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">stream</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">BedTool</span><span class="p">(([</span><span class="n">f</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tmp</span><span class="p">(),</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">])),</span> <span class="n">file</span><span class="o">=</span><span class="n">fh</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">BedTool</span><span class="p">(</span><span class="n">fh</span><span class="o">.</span><span class="n">name</span><span class="p">)</span></div>


    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_tmp</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes a tempfile and registers it in the BedTool.TEMPFILES class</span>
<span class="sd">        variable.  Adds a &quot;pybedtools.&quot; prefix and &quot;.tmp&quot; extension for easy</span>
<span class="sd">        deletion if you forget to call pybedtools.cleanup().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tmpfn</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">NamedTemporaryFile</span><span class="p">(</span>
            <span class="n">prefix</span><span class="o">=</span><span class="n">settings</span><span class="o">.</span><span class="n">tempfile_prefix</span><span class="p">,</span>
            <span class="n">suffix</span><span class="o">=</span><span class="n">settings</span><span class="o">.</span><span class="n">tempfile_suffix</span><span class="p">,</span>
            <span class="n">delete</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">tmpfn</span> <span class="o">=</span> <span class="n">tmpfn</span><span class="o">.</span><span class="n">name</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">TEMPFILES</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmpfn</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tmpfn</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Dispatches the right iterator depending on how this BedTool was</span>
<span class="sd">        created</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isbam</span><span class="p">:</span>
            <span class="c1"># Note: BAM class takes filename or stream, so self.fn is OK</span>
            <span class="c1"># here</span>
            <span class="k">return</span> <span class="n">BAM</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">)</span>

        <span class="c1"># Plain ol&#39; filename</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">BedToolsFileError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> does not exist&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">isGZIP</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">IntervalIterator</span><span class="p">(</span><span class="n">gzip</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">,</span> <span class="s2">&quot;rt&quot;</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">IntervalIterator</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">))</span>
        <span class="c1"># Any other kind of input (streaming string from stdout; iterable of</span>
        <span class="c1"># Intervals, iterable of (chrom, start, stop) tuples, etc are handled</span>
        <span class="c1"># appropriately by IntervalIterator.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">IntervalIterator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">intervals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">IntervalFile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Please convert to a file-based BedTool using saveas&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">remote</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;&lt;BedTool(</span><span class="si">%s</span><span class="s2">)&gt;&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">fn</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;&lt;BedTool(MISSING FILE: </span><span class="si">%s</span><span class="s2">)&gt;&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">fn</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">,</span> <span class="n">BedTool</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&lt;BedTool(</span><span class="si">%s</span><span class="s2">)&gt;&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the string representation of the whole `BedTool`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">items</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">):</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;UTF-8&quot;</span><span class="p">)</span>
            <span class="n">items</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">BedTool</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">other</span><span class="o">.</span><span class="n">fn</span><span class="p">,</span> <span class="nb">str</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;Testing equality only supported for&quot;</span>
                    <span class="s2">&quot; BedTools that point to files&quot;</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Testing equality only supported for&quot;</span>
                <span class="s2">&quot; BedTools that point to files or str of content&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span><span class="nb">object</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">slice</span><span class="o">|</span><span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">islice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">key</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Only slices or integers allowed for indexing &quot;</span> <span class="s2">&quot;into a BedTool&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">BedTool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">BEDToolsError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># BEDTools versions &lt;2.20 would raise BEDToolsError</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_type</span> <span class="o">==</span> <span class="s2">&quot;empty&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">file_type</span> <span class="o">==</span> <span class="s2">&quot;empty&quot;</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">pybedtools</span><span class="o">.</span><span class="n">BedTool</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">from_string</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">e</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">BedTool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">BEDToolsError</span><span class="p">:</span>
            <span class="c1"># BEDTools versions &lt;2.20 would raise BEDToolsError</span>

            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_type</span> <span class="o">==</span> <span class="s2">&quot;empty&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">file_type</span> <span class="o">==</span> <span class="s2">&quot;empty&quot;</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">pybedtools</span><span class="o">.</span><span class="n">BedTool</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">from_string</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">other</span><span class="o">.</span><span class="n">file_type</span> <span class="o">==</span> <span class="s2">&quot;empty&quot;</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">saveas</span><span class="p">()</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_type</span> <span class="o">==</span> <span class="s2">&quot;empty&quot;</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">pybedtools</span><span class="o">.</span><span class="n">BedTool</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">from_string</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Subtraction operation failed.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="BedTool.head">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.head.html#pybedtools.bedtool.BedTool.head">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">head</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">as_string</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prints the first *n* lines or returns them if as_string is True</span>

<span class="sd">        Note that this only opens the underlying file (gzipped or not), so it</span>
<span class="sd">        does not check to see if the file is a valid BED file.</span>

<span class="sd">        &gt;&gt;&gt; a = pybedtools.example_bedtool(&#39;a.bed&#39;)</span>
<span class="sd">        &gt;&gt;&gt; a.head(2) #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        chr1	1	100	feature1	0	+</span>
<span class="sd">        chr1	100	200	feature2	0	+</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;head() not supported for non file-based BedTools&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">as_string</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[:</span><span class="n">n</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isbam</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;head() not supported for BAM&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">isGZIP</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">):</span>
                <span class="n">openfunc</span> <span class="o">=</span> <span class="n">gzip</span><span class="o">.</span><span class="n">open</span>
                <span class="n">openmode</span> <span class="o">=</span> <span class="s2">&quot;rt&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">openfunc</span> <span class="o">=</span> <span class="nb">open</span>
                <span class="n">openmode</span> <span class="o">=</span> <span class="s2">&quot;r&quot;</span>
            <span class="k">with</span> <span class="n">openfunc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">,</span> <span class="n">openmode</span><span class="p">)</span> <span class="k">as</span> <span class="n">fin</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fin</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="p">(</span><span class="n">n</span><span class="p">):</span>
                        <span class="k">break</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="BedTool.set_chromsizes">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.set_chromsizes.html#pybedtools.bedtool.BedTool.set_chromsizes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_chromsizes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chromsizes</span><span class="p">:</span>  <span class="nb">str</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepare BedTool for operations that require chromosome coords.</span>

<span class="sd">        Set the chromsizes for this genome. If *chromsizes* is a string, it</span>
<span class="sd">        will be considered a genome assembly name.  If that assembly name is</span>
<span class="sd">        not available in pybedtools.genome_registry, then it will be searched</span>
<span class="sd">        for on the UCSC Genome Browser.</span>

<span class="sd">        Example usage:</span>

<span class="sd">            &gt;&gt;&gt; hg19 = pybedtools.chromsizes(&#39;hg19&#39;)</span>
<span class="sd">            &gt;&gt;&gt; a = pybedtools.example_bedtool(&#39;a.bed&#39;)</span>
<span class="sd">            &gt;&gt;&gt; a = a.set_chromsizes(hg19)</span>
<span class="sd">            &gt;&gt;&gt; print(a.chromsizes[&#39;chr1&#39;])</span>
<span class="sd">            (0, 249250621)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">chromsizes</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">chromsizes</span> <span class="o">=</span> <span class="n">pybedtools</span><span class="o">.</span><span class="n">chromsizes</span><span class="p">(</span><span class="n">chromsizes</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">chromsizes</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">chromsizes</span> <span class="o">=</span> <span class="n">chromsizes</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Need to specify chromsizes either as a string&quot;</span>
                <span class="s2">&quot; (assembly name) or a dictionary&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_collapse</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">iterable</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">,</span>
        <span class="n">fn</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">trackline</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">in_compressed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">out_compressed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Collapses an iterable into file *fn* (or a new tempfile if *fn* is</span>
<span class="sd">        None).</span>

<span class="sd">        Returns the newly created filename.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        iterable : iter</span>
<span class="sd">            Any iterable object whose items can be converted to an Interval.</span>

<span class="sd">        fn : str</span>
<span class="sd">            Output filename, if None then creates a temp file for output</span>

<span class="sd">        trackline : str</span>
<span class="sd">            If not None, string to be added to the top of the output. Newline</span>
<span class="sd">            will be added.</span>

<span class="sd">        in_compressed : bool</span>
<span class="sd">            Indicates whether the input is compressed</span>

<span class="sd">        out_compressed : bool</span>
<span class="sd">            Indicates whether the output should be compressed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmp</span><span class="p">()</span>

        <span class="n">in_open_func</span> <span class="o">=</span> <span class="n">gzip</span><span class="o">.</span><span class="n">open</span> <span class="k">if</span> <span class="n">in_compressed</span> <span class="k">else</span> <span class="nb">open</span>
        <span class="n">out_open_func</span> <span class="o">=</span> <span class="n">gzip</span><span class="o">.</span><span class="n">open</span> <span class="k">if</span> <span class="n">out_compressed</span> <span class="k">else</span> <span class="nb">open</span>

        <span class="c1"># special case: if BAM-format BedTool is provided, no trackline should</span>
        <span class="c1"># be supplied, and don&#39;t iterate -- copy the file wholesale</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">BedTool</span><span class="p">)</span> <span class="ow">and</span> <span class="n">iterable</span><span class="o">.</span><span class="n">_isbam</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">trackline</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;trackline provided, but input is a BAM &quot;</span>
                    <span class="s2">&quot;file, which takes no track line&quot;</span>
                <span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">out_</span><span class="p">:</span>
                <span class="n">out_</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
            <span class="k">return</span> <span class="n">fn</span>

        <span class="c1"># If we&#39;re just working with filename-based BedTool objects, just copy</span>
        <span class="c1"># the files directly</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">BedTool</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">iterable</span><span class="o">.</span><span class="n">fn</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">with</span> <span class="n">out_open_func</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="s2">&quot;wt&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">out_</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">):</span>
                    <span class="n">in_</span> <span class="o">=</span> <span class="n">in_open_func</span><span class="p">(</span><span class="n">iterable</span><span class="o">.</span><span class="n">fn</span><span class="p">,</span> <span class="s2">&quot;rt&quot;</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">in_</span> <span class="o">=</span> <span class="n">in_open_func</span><span class="p">(</span><span class="n">iterable</span><span class="o">.</span><span class="n">fn</span><span class="p">,</span> <span class="s2">&quot;rt&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">trackline</span><span class="p">:</span>
                    <span class="n">out_</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">trackline</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">out_</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span><span class="n">in_</span><span class="p">)</span>
                <span class="n">in_</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">out_open_func</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="s2">&quot;wt&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">out_</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                        <span class="n">i</span> <span class="o">=</span> <span class="n">create_interval_from_list</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
                    <span class="n">out_</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">fn</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">handle_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prog</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">arg_order</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Handle most cases of BEDTool program calls, but leave the specifics</span>
<span class="sd">        up to individual methods.</span>

<span class="sd">        *prog* is a BEDTools program name, e.g., &#39;intersectBed&#39;.</span>

<span class="sd">        *arg_order* lists any arguments that are sensitive to order. Everything</span>
<span class="sd">        else will be reverse-sorted.</span>

<span class="sd">        *kwargs* are passed directly from the calling method (like</span>
<span class="sd">        self.intersect).</span>

<span class="sd">        This method figures out, given how this BedTool was constructed, what</span>
<span class="sd">        to send to BEDTools programs -- for example, an open file to stdin with</span>
<span class="sd">        the `-` argument, or a filename with the `-a` argument.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pybedtools</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;BedTool.handle_kwargs() got these kwargs:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># If you pass in a list, how should it be converted to a BedTools arg?</span>
        <span class="n">default_list_delimiter</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span>
        <span class="n">list_delimiters</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;annotateBed&quot;</span><span class="p">:</span> <span class="s2">&quot; &quot;</span><span class="p">,</span>
            <span class="s2">&quot;getOverlap&quot;</span><span class="p">:</span> <span class="s2">&quot;,&quot;</span><span class="p">,</span>
            <span class="s2">&quot;groupBy&quot;</span><span class="p">:</span> <span class="s2">&quot;,&quot;</span><span class="p">,</span>
            <span class="s2">&quot;multiIntersectBed&quot;</span><span class="p">:</span> <span class="s2">&quot; &quot;</span><span class="p">,</span>
            <span class="s2">&quot;mergeBed&quot;</span><span class="p">:</span> <span class="s2">&quot;,&quot;</span><span class="p">,</span>
            <span class="s2">&quot;intersectBed&quot;</span><span class="p">:</span> <span class="s2">&quot; &quot;</span><span class="p">,</span>
            <span class="s2">&quot;mapBed&quot;</span><span class="p">:</span> <span class="s2">&quot;,&quot;</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">stdin</span> <span class="o">=</span> <span class="kc">None</span>
   
        <span class="c1"># If anything in kwargs is a pathlib Path, convert to string here.</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">PurePath</span><span class="p">):</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="c1"># -----------------------------------------------------------------</span>
        <span class="c1"># Decide how to send instream1 to BEDTools.  If there&#39;s no implicit</span>
        <span class="c1"># instream1 arg, then do nothing.</span>
        <span class="c1">#</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># e.g., &#39;a&#39; for intersectBed</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isbam</span><span class="p">:</span>
                <span class="n">inarg1</span> <span class="o">=</span> <span class="n">_bam_registry</span><span class="p">[</span><span class="n">prog</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">inarg1</span> <span class="o">=</span> <span class="n">_implicit_registry</span><span class="p">[</span><span class="n">prog</span><span class="p">]</span>

            <span class="c1"># e.g., self.fn or &#39;a.bed&#39; or an iterator...</span>
            <span class="n">instream1</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">inarg1</span><span class="p">]</span>

            <span class="c1"># If it&#39;s a BedTool, then get underlying stream</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">instream1</span><span class="p">,</span> <span class="n">BedTool</span><span class="p">):</span>
                <span class="n">instream1</span> <span class="o">=</span> <span class="n">instream1</span><span class="o">.</span><span class="n">fn</span>

            <span class="c1"># Filename? No pipe, just provide the file</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">instream1</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">inarg1</span><span class="p">]</span> <span class="o">=</span> <span class="n">instream1</span>
                <span class="n">stdin</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># Open file? Pipe it</span>
            <span class="c1"># elif isinstance(instream1, file):</span>
            <span class="c1">#     kwargs[inarg1] = &#39;stdin&#39;</span>
            <span class="c1">#     stdin = instream1</span>

            <span class="c1"># A generator or iterator: pipe it as a generator of lines</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">inarg1</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;stdin&quot;</span>
                <span class="n">stdin</span> <span class="o">=</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">instream1</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c1"># -----------------------------------------------------------------</span>
        <span class="c1"># Decide how to send instream2 to BEDTools.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># e.g., &#39;b&#39; for intersectBed</span>
            <span class="n">inarg2</span> <span class="o">=</span> <span class="n">_other_registry</span><span class="p">[</span><span class="n">prog</span><span class="p">]</span>

            <span class="c1"># e.g., another BedTool</span>
            <span class="n">instream2</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">inarg2</span><span class="p">]</span>

            <span class="c1"># Get stream if BedTool</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">instream2</span><span class="p">,</span> <span class="n">BedTool</span><span class="p">):</span>
                <span class="n">instream2</span> <span class="o">=</span> <span class="n">instream2</span><span class="o">.</span><span class="n">fn</span>

            <span class="c1"># Filename</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">instream2</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">inarg2</span><span class="p">]</span> <span class="o">=</span> <span class="n">instream2</span>

            <span class="c1"># If it&#39;s a list of strings, then we need to figure out if it&#39;s</span>
            <span class="c1"># a list of filenames or a list of intervals (see issue #156)</span>
            <span class="c1">#</span>
            <span class="c1"># Several options:</span>
            <span class="c1">#</span>
            <span class="c1">#   - assume intervals have tabs but filenames don&#39;t</span>
            <span class="c1">#   - assume that, upon being split on tabs, an interval is &gt;=3 fields</span>
            <span class="c1">#   - try creating an interval out of the first thing, success means interval</span>
            <span class="c1">#</span>
            <span class="c1"># The last seems the most robust. It does allow filenames with</span>
            <span class="c1"># tabs; deciding whether or not such filenames are a good idea is</span>
            <span class="c1"># left to the user.</span>
            <span class="c1">#</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">instream2</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">instream2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span>
            <span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">_</span> <span class="o">=</span> <span class="n">create_interval_from_list</span><span class="p">(</span><span class="n">instream2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">))</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="n">inarg2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_collapse</span><span class="p">(</span><span class="n">instream2</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="n">inarg2</span><span class="p">]</span> <span class="o">=</span> <span class="n">instream2</span>

            <span class="c1"># Otherwise we need to collapse it in order to send to BEDTools</span>
            <span class="c1"># programs</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">inarg2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_collapse</span><span class="p">(</span><span class="n">instream2</span><span class="p">)</span>

        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c1"># If stream not specified, then a tempfile will be created</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;stream&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;output&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">output</span><span class="p">:</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">output</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmp</span><span class="p">()</span>

        <span class="n">additional_args</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;additional_args&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Parse the kwargs into BEDTools-ready args</span>
        <span class="n">cmds</span> <span class="o">=</span> <span class="p">[</span><span class="n">prog</span><span class="p">]</span>

        <span class="c1"># arg_order mechanism added to fix #345</span>
        <span class="k">if</span> <span class="n">arg_order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">arg_order</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">arg_order</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
                <span class="n">cmds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">+</span> <span class="n">arg</span><span class="p">)</span>
                <span class="n">cmds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="c1"># The reverse-sort is a temp fix for issue #81</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">value</span><span class="p">:</span>
                    <span class="n">cmds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">+</span> <span class="n">key</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">continue</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">delim</span> <span class="o">=</span> <span class="n">list_delimiters</span><span class="p">[</span><span class="n">prog</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="n">delim</span> <span class="o">=</span> <span class="n">default_list_delimiter</span>

                <span class="k">if</span> <span class="n">delim</span> <span class="o">==</span> <span class="s2">&quot; &quot;</span><span class="p">:</span>
                    <span class="n">cmds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">+</span> <span class="n">key</span><span class="p">)</span>
                    <span class="n">cmds</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

                <span class="c1"># make comma-separated list if that&#39;s what&#39;s needed</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cmds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">+</span> <span class="n">key</span><span class="p">)</span>
                    <span class="n">cmds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">delim</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">cmds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">+</span> <span class="n">key</span><span class="p">)</span>
                <span class="n">cmds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">additional_args</span><span class="p">:</span>
            <span class="n">cmds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">additional_args</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cmds</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">stdin</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">check_genome</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Handles the different ways of specifying a genome in kwargs:</span>

<span class="sd">        g=&#39;genome.file&#39; specifies a file directly</span>
<span class="sd">        genome=&#39;dm3&#39; gets the file from genome registry</span>
<span class="sd">        self.chromsizes could be a dict.\</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If both g and genome are missing, assume self.chromsizes</span>
        <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;g&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="s2">&quot;genome&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;chromsizes&quot;</span><span class="p">):</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;g&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chromsizes</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;No genome specified. Use the &quot;g&quot; or &#39;</span>
                    <span class="s1">&#39;&quot;genome&quot; kwargs, or use the &#39;</span>
                    <span class="s2">&quot;.set_chromsizes() method&quot;</span>
                <span class="p">)</span>

        <span class="c1"># If both specified, rather than make an implicit decision, raise an</span>
        <span class="c1"># exception</span>
        <span class="k">if</span> <span class="s2">&quot;g&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="s2">&quot;genome&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot specify both &quot;g&quot; and &quot;genome&quot;&#39;</span><span class="p">)</span>

        <span class="c1"># Something like genome=&#39;dm3&#39; was specified</span>
        <span class="k">if</span> <span class="s2">&quot;g&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="s2">&quot;genome&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;genome&quot;</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">genome_dict</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;genome&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">genome_dict</span> <span class="o">=</span> <span class="n">pybedtools</span><span class="o">.</span><span class="n">chromsizes</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;genome&quot;</span><span class="p">])</span>
            <span class="n">genome_file</span> <span class="o">=</span> <span class="n">pybedtools</span><span class="o">.</span><span class="n">chromsizes_to_file</span><span class="p">(</span><span class="n">genome_dict</span><span class="p">)</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;g&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">genome_file</span>
            <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;genome&quot;</span><span class="p">]</span>

        <span class="c1"># By the time we get here, &#39;g&#39; is specified.</span>

        <span class="c1"># If a dict was provided, convert to tempfile here</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;g&quot;</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;g&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pybedtools</span><span class="o">.</span><span class="n">chromsizes_to_file</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;g&quot;</span><span class="p">])</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;g&quot;</span><span class="p">]):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Genome file &quot;</span><span class="si">%s</span><span class="s1">&quot; does not exist&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;g&quot;</span><span class="p">])</span>
            <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">kwargs</span>

<div class="viewcode-block" id="BedTool.remove_invalid">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.remove_invalid.html#pybedtools.bedtool.BedTool.remove_invalid">[docs]</a>
    <span class="nd">@_log_to_history</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">remove_invalid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove invalid features that may break BEDTools programs.</span>

<span class="sd">        &gt;&gt;&gt; a = pybedtools.BedTool(&quot;chr1 10 100\\nchr1 10 1&quot;,</span>
<span class="sd">        ... from_string=True)</span>
<span class="sd">        &gt;&gt;&gt; print(a.remove_invalid()) #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        chr1	10	100</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmp</span><span class="p">()</span>

        <span class="c1"># If it&#39;s a file-based BedTool -- which is likely, if we&#39;re trying to</span>
        <span class="c1"># remove invalid features -- then we need to parse it line by line.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">IntervalIterator</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">saveas</span><span class="p">()</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">IntervalIterator</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">fn</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">))</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_generator</span><span class="p">():</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">feature</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">feature</span><span class="o">.</span><span class="n">start</span> <span class="o">&lt;=</span> <span class="n">feature</span><span class="o">.</span><span class="n">stop</span><span class="p">:</span>
                        <span class="k">yield</span> <span class="n">feature</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">continue</span>
                <span class="k">except</span> <span class="n">pybedtools</span><span class="o">.</span><span class="n">MalformedBedLineError</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">except</span> <span class="ne">OverflowError</span><span class="p">:</span>
                    <span class="c1"># This can happen if coords are negative</span>
                    <span class="k">continue</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                    <span class="k">break</span>

        <span class="k">return</span> <span class="n">BedTool</span><span class="p">(</span><span class="n">_generator</span><span class="p">())</span></div>


<div class="viewcode-block" id="BedTool.all_hits">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.all_hits.html#pybedtools.bedtool.BedTool.all_hits">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">all_hits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval</span><span class="p">:</span> <span class="n">Interval</span><span class="p">,</span> <span class="n">same_strand</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">overlap</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return all intervals that overlap `interval`.</span>

<span class="sd">        Calls the `all_hits` method of an IntervalFile to return all intervals</span>
<span class="sd">        in this current BedTool that overlap `interval`.</span>

<span class="sd">        Require that overlaps have the same strand with same_strand=True.</span>

<span class="sd">        Notes:</span>
<span class="sd">                If this current BedTool is generator-based, it will be</span>
<span class="sd">                converted into a file first.</span>

<span class="sd">                If this current BedTool refers to a BAM file, it will be</span>
<span class="sd">                converted to a BED file first using default arguments.  If you</span>
<span class="sd">                don&#39;t want this to happen, please convert to BED first before</span>
<span class="sd">                using this method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">Interval</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Need an Interval instance&quot;</span><span class="p">)</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fn</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">saveas</span><span class="p">()</span><span class="o">.</span><span class="n">fn</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isbam</span><span class="p">:</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bam_to_bed</span><span class="p">()</span><span class="o">.</span><span class="n">fn</span>
        <span class="n">interval_file</span> <span class="o">=</span> <span class="n">pybedtools</span><span class="o">.</span><span class="n">IntervalFile</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">interval_file</span><span class="o">.</span><span class="n">all_hits</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">same_strand</span><span class="p">,</span> <span class="n">overlap</span><span class="p">)</span></div>


<div class="viewcode-block" id="BedTool.any_hits">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.any_hits.html#pybedtools.bedtool.BedTool.any_hits">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">any_hits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval</span><span class="p">:</span> <span class="n">Interval</span><span class="p">,</span> <span class="n">same_strand</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">overlap</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether or not any intervals overlap `interval`.</span>

<span class="sd">        Calls the `any_hits` method of an IntervalFile.  If there were any hits</span>
<span class="sd">        within `interval` in this BedTool, then return 1; otherwise 0.</span>

<span class="sd">        Require that overlaps have the same strand with same_strand=True.</span>

<span class="sd">        Notes:</span>
<span class="sd">                If this current BedTool is generator-based, it will be</span>
<span class="sd">                converted into a file first.</span>

<span class="sd">                If this current BedTool refers to a BAM file, it will be</span>
<span class="sd">                converted to a BED file first using default arguments.  If you</span>
<span class="sd">                don&#39;t want this to happen, please convert to BED first before</span>
<span class="sd">                using this method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">Interval</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Need an Interval instance&quot;</span><span class="p">)</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fn</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">saveas</span><span class="p">()</span><span class="o">.</span><span class="n">fn</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isbam</span><span class="p">:</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bam_to_bed</span><span class="p">()</span><span class="o">.</span><span class="n">fn</span>
        <span class="n">interval_file</span> <span class="o">=</span> <span class="n">pybedtools</span><span class="o">.</span><span class="n">IntervalFile</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">interval_file</span><span class="o">.</span><span class="n">any_hits</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">same_strand</span><span class="p">,</span> <span class="n">overlap</span><span class="p">)</span></div>


<div class="viewcode-block" id="BedTool.count_hits">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.count_hits.html#pybedtools.bedtool.BedTool.count_hits">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">count_hits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval</span><span class="p">:</span> <span class="n">Interval</span><span class="p">,</span> <span class="n">same_strand</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">overlap</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of intervals that overlap `interval`.</span>

<span class="sd">        Calls the `count_hits` method of an IntervalFile.  Returns the number</span>
<span class="sd">        of valid hits in this BedTool that overlap `interval`.</span>

<span class="sd">        Require that overlaps have the same strand with same_strand=True.</span>

<span class="sd">        Notes:</span>
<span class="sd">                If this current BedTool is generator-based, it will be</span>
<span class="sd">                converted into a file first.</span>

<span class="sd">                If this current BedTool refers to a BAM file, it will be</span>
<span class="sd">                converted to a BED file first using default arguments.  If you</span>
<span class="sd">                don&#39;t want this to happen, please convert to BED first before</span>
<span class="sd">                using this method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">Interval</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Need an Interval instance&quot;</span><span class="p">)</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fn</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">saveas</span><span class="p">()</span><span class="o">.</span><span class="n">fn</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isbam</span><span class="p">:</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bam_to_bed</span><span class="p">()</span><span class="o">.</span><span class="n">fn</span>
        <span class="n">interval_file</span> <span class="o">=</span> <span class="n">pybedtools</span><span class="o">.</span><span class="n">IntervalFile</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">interval_file</span><span class="o">.</span><span class="n">count_hits</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">same_strand</span><span class="p">,</span> <span class="n">overlap</span><span class="p">)</span></div>


<div class="viewcode-block" id="BedTool.bed6">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.bed6.html#pybedtools.bedtool.BedTool.bed6">[docs]</a>
    <span class="nd">@_log_to_history</span>
    <span class="nd">@_wraps</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s2">&quot;bed12ToBed6&quot;</span><span class="p">,</span> <span class="n">implicit</span><span class="o">=</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="n">bam</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">bed6</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span> <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps `bedtools bed12tobed6`.</span>
<span class="sd">        &quot;&quot;&quot;</span></div>


    <span class="c1"># Alias for backward compatibility</span>
    <span class="n">bed12tobed6</span> <span class="o">=</span> <span class="n">bed6</span>

<div class="viewcode-block" id="BedTool.bam_to_bed">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.bam_to_bed.html#pybedtools.bedtool.BedTool.bam_to_bed">[docs]</a>
    <span class="nd">@_log_to_history</span>
    <span class="nd">@_wraps</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s2">&quot;bamToBed&quot;</span><span class="p">,</span> <span class="n">implicit</span><span class="o">=</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nonbam</span><span class="o">=</span><span class="s2">&quot;ALL&quot;</span><span class="p">,</span> <span class="n">bam</span><span class="o">=</span><span class="s2">&quot;i&quot;</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">bam_to_bed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span> <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps `bedtools bamtobed`.</span>
<span class="sd">        &quot;&quot;&quot;</span></div>


    <span class="c1"># Alias for backward compatibility</span>
    <span class="n">bamtobed</span> <span class="o">=</span> <span class="n">bam_to_bed</span>

    <span class="nd">@_wraps</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s2">&quot;bedToBam&quot;</span><span class="p">,</span> <span class="n">implicit</span><span class="o">=</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="n">uses_genome</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">force_bam</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_bed_to_bam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps bedToBam and is called internally for BED/GFF/VCF files by</span>
<span class="sd">        self.to_bam (which needs to do something different for SAM files...)</span>
<span class="sd">        &quot;&quot;&quot;</span>

<div class="viewcode-block" id="BedTool.to_bam">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.to_bam.html#pybedtools.bedtool.BedTool.to_bam">[docs]</a>
    <span class="nd">@_log_to_history</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_bam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps `bedtools bedtobam`</span>

<span class="sd">        If self.fn is in BED/VCF/GFF format, call BEDTools&#39; bedToBam.  If</span>
<span class="sd">        self.fn is in SAM format, then create a header out of the genome file</span>
<span class="sd">        and then convert using `samtools`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_type</span> <span class="o">==</span> <span class="s2">&quot;bam&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;bed&quot;</span><span class="p">,</span> <span class="s2">&quot;gff&quot;</span><span class="p">,</span> <span class="s2">&quot;vcf&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bed_to_bam</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># TODO: to maintain backwards compatibility we go from Interval to</span>
        <span class="c1"># AlignedSegment.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_type</span> <span class="o">==</span> <span class="s2">&quot;sam&quot;</span><span class="p">:</span>

            <span class="c1"># Use pysam, but construct the header out of a provided genome</span>
            <span class="c1"># file.</span>

            <span class="c1"># construct a genome out of whatever kwargs were passed in</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_genome</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="c1"># Build a header that we can use for the output BAM file.</span>
            <span class="n">genome</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">split</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;g&quot;</span><span class="p">]))</span>
            <span class="n">SQ</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">ref_ids</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">text_header</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;@HD</span><span class="se">\t</span><span class="s2">VN:1.0&quot;</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">genome</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="n">SQ</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">SN</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">LN</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span>
                <span class="n">ref_ids</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
                <span class="n">text_header</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;@SQ</span><span class="se">\t</span><span class="s2">SN:</span><span class="si">{0}</span><span class="se">\t</span><span class="s2">LN:</span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>

            <span class="c1"># And the text-format header</span>
            <span class="n">text_header</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">text_header</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

            <span class="c1"># The strategy is to write an actual SAM file to disk, along with</span>
            <span class="c1"># a header, and then read that back in.</span>
            <span class="c1">#</span>
            <span class="c1"># Painfully inefficient, but this will change once all py2 tests</span>
            <span class="c1"># pass.</span>
            <span class="n">sam_tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmp</span><span class="p">()</span>
            <span class="n">bam_tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmp</span><span class="p">()</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">sam_tmp</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fout</span><span class="p">:</span>
                <span class="n">fout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">text_header</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="n">fout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">interval</span><span class="o">.</span><span class="n">fields</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">samfile</span> <span class="o">=</span> <span class="n">pysam</span><span class="o">.</span><span class="n">AlignmentFile</span><span class="p">(</span><span class="n">sam_tmp</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
            <span class="n">bamfile</span> <span class="o">=</span> <span class="n">pysam</span><span class="o">.</span><span class="n">AlignmentFile</span><span class="p">(</span><span class="n">bam_tmp</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">,</span> <span class="n">template</span><span class="o">=</span><span class="n">samfile</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">alignment</span> <span class="ow">in</span> <span class="n">samfile</span><span class="p">:</span>
                <span class="n">bamfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">alignment</span><span class="p">)</span>

            <span class="n">samfile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">bamfile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">new_bedtool</span> <span class="o">=</span> <span class="n">BedTool</span><span class="p">(</span><span class="n">bam_tmp</span><span class="p">)</span>
            <span class="n">new_bedtool</span><span class="o">.</span><span class="n">_isbam</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="n">new_bedtool</span></div>


    <span class="c1"># Alias for backward compatibility</span>
    <span class="n">bedtobam</span> <span class="o">=</span> <span class="n">to_bam</span>

<div class="viewcode-block" id="BedTool.intersect">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.intersect.html#pybedtools.bedtool.BedTool.intersect">[docs]</a>
    <span class="nd">@_log_to_history</span>
    <span class="nd">@_wraps</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s2">&quot;intersectBed&quot;</span><span class="p">,</span> <span class="n">implicit</span><span class="o">=</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">bam</span><span class="o">=</span><span class="s2">&quot;abam&quot;</span><span class="p">,</span>
            <span class="n">nonbam</span><span class="o">=</span><span class="s2">&quot;bed&quot;</span><span class="p">,</span> <span class="n">arg_order</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;abam&quot;</span><span class="p">])</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">intersect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span>  <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps `bedtools intersect`.</span>
<span class="sd">        &quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="BedTool.sequence">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.sequence.html#pybedtools.bedtool.BedTool.sequence">[docs]</a>
    <span class="nd">@_log_to_history</span>
    <span class="nd">@_wraps</span><span class="p">(</span>
        <span class="n">prog</span><span class="o">=</span><span class="s2">&quot;fastaFromBed&quot;</span><span class="p">,</span>
        <span class="n">implicit</span><span class="o">=</span><span class="s2">&quot;bed&quot;</span><span class="p">,</span>
        <span class="n">bam</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">other</span><span class="o">=</span><span class="s2">&quot;fi&quot;</span><span class="p">,</span>
        <span class="n">make_tempfile_for</span><span class="o">=</span><span class="s2">&quot;fo&quot;</span><span class="p">,</span>
        <span class="n">check_stderr</span><span class="o">=</span><span class="n">_check_sequence_stderr</span><span class="p">,</span>
        <span class="n">add_to_bedtool</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;fo&quot;</span><span class="p">:</span> <span class="s2">&quot;seqfn&quot;</span><span class="p">},</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span>  <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Wraps `bedtools getfasta`.</span>

<span class="sd">        *fi* is passed in by the user; *bed* is automatically passed in as the</span>
<span class="sd">        bedfile of this object; *fo* by default is a temp file.  Use</span>
<span class="sd">        save_seqs() to save as a file.</span>

<span class="sd">        The end result is that this BedTool will assign a value to the attribute , self.seqfn,</span>
<span class="sd">        that points to the new fasta file.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; a = pybedtools.BedTool(&quot;&quot;&quot;</span>
<span class="sd">        ... chr1 1 10</span>
<span class="sd">        ... chr1 50 55&quot;&quot;&quot;, from_string=True)</span>
<span class="sd">        &gt;&gt;&gt; fasta = pybedtools.example_filename(&#39;test.fa&#39;)</span>
<span class="sd">        &gt;&gt;&gt; a = a.sequence(fi=fasta)</span>
<span class="sd">        &gt;&gt;&gt; print(open(a.seqfn).read())</span>
<span class="sd">        &gt;chr1:1-10</span>
<span class="sd">        GATGAGTCT</span>
<span class="sd">        &gt;chr1:50-55</span>
<span class="sd">        CCATC</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>

<span class="sd">        &#39;&#39;&#39;</span></div>


    <span class="c1"># Alias for backwards compatibility</span>
    <span class="n">getfasta</span> <span class="o">=</span> <span class="n">sequence</span>

<div class="viewcode-block" id="BedTool.seq">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.seq.html#pybedtools.bedtool.BedTool.seq">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">seq</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">fasta</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return just the sequence from a region string or a single location</span>
<span class="sd">        &gt;&gt;&gt; fn = pybedtools.example_filename(&#39;test.fa&#39;)</span>
<span class="sd">        &gt;&gt;&gt; BedTool.seq(&#39;chr1:2-10&#39;, fn)</span>
<span class="sd">        &#39;GATGAGTCT&#39;</span>
<span class="sd">        &gt;&gt;&gt; BedTool.seq((&#39;chr1&#39;, 1, 10), fn)</span>
<span class="sd">        &#39;GATGAGTCT&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">chrom</span><span class="p">,</span> <span class="n">start_end</span> <span class="o">=</span> <span class="n">loc</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">start_end</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">)))</span>
            <span class="n">start</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">chrom</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">loc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">loc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="n">loc</span> <span class="o">=</span> <span class="n">BedTool</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="se">\t</span><span class="si">%i</span><span class="se">\t</span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">chrom</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">),</span> <span class="n">from_string</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">lseq</span> <span class="o">=</span> <span class="n">loc</span><span class="o">.</span><span class="n">sequence</span><span class="p">(</span><span class="n">fi</span><span class="o">=</span><span class="n">fasta</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">l</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="n">lseq</span><span class="o">.</span><span class="n">seqfn</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">])</span></div>


<div class="viewcode-block" id="BedTool.nucleotide_content">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.nucleotide_content.html#pybedtools.bedtool.BedTool.nucleotide_content">[docs]</a>
    <span class="nd">@_log_to_history</span>
    <span class="nd">@_wraps</span><span class="p">(</span>
        <span class="n">prog</span><span class="o">=</span><span class="s2">&quot;nucBed&quot;</span><span class="p">,</span> <span class="n">implicit</span><span class="o">=</span><span class="s2">&quot;bed&quot;</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="s2">&quot;fi&quot;</span><span class="p">,</span> <span class="n">check_stderr</span><span class="o">=</span><span class="n">_check_sequence_stderr</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nucleotide_content</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span>  <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps `bedtools nuc`.</span>

<span class="sd">        Profiles nucleotide content.  The returned BED file contains extra</span>
<span class="sd">        information about the nucleotide content</span>
<span class="sd">        &quot;&quot;&quot;</span></div>


    <span class="c1"># Alias for backwards compatibility</span>
    <span class="n">nuc</span> <span class="o">=</span> <span class="n">nucleotide_content</span>

<div class="viewcode-block" id="BedTool.multi_bam_coverage">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.multi_bam_coverage.html#pybedtools.bedtool.BedTool.multi_bam_coverage">[docs]</a>
    <span class="nd">@_log_to_history</span>
    <span class="nd">@_wraps</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s2">&quot;multiBamCov&quot;</span><span class="p">,</span> <span class="n">implicit</span><span class="o">=</span><span class="s2">&quot;bed&quot;</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">multi_bam_coverage</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span>  <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps `bedtools multicov`.</span>

<span class="sd">        Pass a list of sorted and indexed BAM files as `bams`</span>
<span class="sd">        &quot;&quot;&quot;</span></div>


    <span class="c1"># Alias for backwards compatibility</span>
    <span class="n">multicov</span> <span class="o">=</span> <span class="n">multi_bam_coverage</span>

<div class="viewcode-block" id="BedTool.subtract">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.subtract.html#pybedtools.bedtool.BedTool.subtract">[docs]</a>
    <span class="nd">@_log_to_history</span>
    <span class="nd">@_wraps</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s2">&quot;subtractBed&quot;</span><span class="p">,</span> <span class="n">implicit</span><span class="o">=</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">bam</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">subtract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span> <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps `bedtools subtract`.</span>

<span class="sd">        Subtracts from another BED file and returns a new BedTool object.</span>

<span class="sd">        Example usage:</span>

<span class="sd">            &gt;&gt;&gt; a = pybedtools.example_bedtool(&#39;a.bed&#39;)</span>
<span class="sd">            &gt;&gt;&gt; b = pybedtools.example_bedtool(&#39;b.bed&#39;)</span>

<span class="sd">            Do a &quot;stranded&quot; subtraction:</span>

<span class="sd">            &gt;&gt;&gt; c = a.subtract(b, s=True)</span>

<span class="sd">            Require 50% of features in `a` to overlap:</span>

<span class="sd">            &gt;&gt;&gt; c = a.subtract(b, f=0.5)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;a&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fn</span>

        <span class="k">if</span> <span class="s2">&quot;b&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;b&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must specify a BED file to subtract, either as a positional argument or as the &#39;b&#39; keyword argument.&quot;</span><span class="p">)</span>

        <span class="n">cmds</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">stdin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_kwargs</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s2">&quot;subtractBed&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">stream</span> <span class="o">=</span> <span class="n">call_bedtools</span><span class="p">(</span><span class="n">cmds</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">stdin</span><span class="o">=</span><span class="n">stdin</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BedTool</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span></div>


<div class="viewcode-block" id="BedTool.slop">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.slop.html#pybedtools.bedtool.BedTool.slop">[docs]</a>
    <span class="nd">@_log_to_history</span>
    <span class="nd">@_wraps</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s2">&quot;slopBed&quot;</span><span class="p">,</span> <span class="n">implicit</span><span class="o">=</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bam</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">uses_genome</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">slop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span> <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps `bedtools slop`.</span>
<span class="sd">        &quot;&quot;&quot;</span></div>


    <span class="nd">@_log_to_history</span>
    <span class="nd">@_wraps</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s2">&quot;shiftBed&quot;</span><span class="p">,</span> <span class="n">implicit</span><span class="o">=</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bam</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">uses_genome</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span> <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps `bedtools shift`.</span>

<span class="sd">        Shift each feature by user-defined number of bases. Returns a new BedTool object.</span>

<span class="sd">        Example usage:</span>

<span class="sd">            &gt;&gt;&gt; a = pybedtools.example_bedtool(&#39;a.bed&#39;)</span>

<span class="sd">            Shift every feature by 5bp:</span>

<span class="sd">            &gt;&gt;&gt; b = a.shift(genome=&#39;hg19&#39;, s=5)</span>
<span class="sd">            &gt;&gt;&gt; print(b) #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">            chr1	6	105	feature1	0	+</span>
<span class="sd">            chr1	105	205	feature2	0	+</span>
<span class="sd">            chr1	155	505	feature3	0	-</span>
<span class="sd">            chr1	905	955	feature4	0	+</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>

<span class="sd">            Shift features on the &#39;+&#39; strand by -1bp and on &#39;-&#39; strand by +3bp:</span>

<span class="sd">            &gt;&gt;&gt; b = a.shift(genome=&#39;hg19&#39;, p=-1, m=3)</span>
<span class="sd">            &gt;&gt;&gt; print(b) #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">            chr1	0	99	feature1	0	+</span>
<span class="sd">            chr1	99	199	feature2	0	+</span>
<span class="sd">            chr1	153	503	feature3	0	-</span>
<span class="sd">            chr1	899	949	feature4	0	+</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>

<span class="sd">            # Disabling, see https://github.com/arq5x/bedtools2/issues/807</span>
<span class="sd">            Shift features by a fraction of their length (0.50):</span>

<span class="sd">            #&gt;&gt;&gt; b = a.shift(genome=&#39;hg19&#39;, pct=True, s=0.50)</span>
<span class="sd">            #&gt;&gt;&gt; print(b) #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">            #chr1	50	149	feature1	0	+</span>
<span class="sd">            #chr1	150	250	feature2	0	+</span>
<span class="sd">            #chr1	325	675	feature3	0	-</span>
<span class="sd">            #chr1	925	975	feature4	0	+</span>
<span class="sd">            #&lt;BLANKLINE&gt;</span>

<span class="sd">        &quot;&quot;&quot;</span>

<div class="viewcode-block" id="BedTool.merge">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.merge.html#pybedtools.bedtool.BedTool.merge">[docs]</a>
    <span class="nd">@_log_to_history</span>
    <span class="nd">@_wraps</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s2">&quot;mergeBed&quot;</span><span class="p">,</span> <span class="n">implicit</span><span class="o">=</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bam</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span> <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps `bedtools merge`.</span>

<span class="sd">        Merge overlapping features together. Returns a new BedTool object.</span>

<span class="sd">        Example usage:</span>

<span class="sd">            &gt;&gt;&gt; a = pybedtools.example_bedtool(&#39;a.bed&#39;)</span>

<span class="sd">            Merge:</span>

<span class="sd">            &gt;&gt;&gt; c = a.merge()</span>

<span class="sd">            Allow merging of features 500 bp apart:</span>

<span class="sd">            &gt;&gt;&gt; c = a.merge(d=500)</span>

<span class="sd">        &quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="BedTool.closest">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.closest.html#pybedtools.bedtool.BedTool.closest">[docs]</a>
    <span class="nd">@_log_to_history</span>
    <span class="nd">@_wraps</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s2">&quot;closestBed&quot;</span><span class="p">,</span> <span class="n">implicit</span><span class="o">=</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">bam</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">closest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span> <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps `bedtools closest`.</span>

<span class="sd">        Return a new BedTool object containing closest features in *b*.  Note</span>
<span class="sd">        that the resulting file is no longer a valid BED format; use the</span>
<span class="sd">        special &quot;_closest&quot; methods to work with the resulting file.</span>

<span class="sd">        Example usage::</span>

<span class="sd">            a = BedTool(&#39;in.bed&#39;)</span>

<span class="sd">            # get the closest feature in &#39;other.bed&#39; on the same strand</span>
<span class="sd">            b = a.closest(&#39;other.bed&#39;, s=True)</span>

<span class="sd">        &quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="BedTool.window">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.window.html#pybedtools.bedtool.BedTool.window">[docs]</a>
    <span class="nd">@_log_to_history</span>
    <span class="nd">@_wraps</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s2">&quot;windowBed&quot;</span><span class="p">,</span> <span class="n">implicit</span><span class="o">=</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">bam</span><span class="o">=</span><span class="s2">&quot;abam&quot;</span><span class="p">,</span> <span class="n">nonbam</span><span class="o">=</span><span class="s2">&quot;bed&quot;</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">window</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span> <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps `bedtools window`.</span>

<span class="sd">        Example usage::</span>

<span class="sd">            &gt;&gt;&gt; a = pybedtools.example_bedtool(&#39;a.bed&#39;)</span>
<span class="sd">            &gt;&gt;&gt; b = pybedtools.example_bedtool(&#39;b.bed&#39;)</span>
<span class="sd">            &gt;&gt;&gt; print(a.window(b, w=1000)) #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">            chr1	1	100	feature1	0	+	chr1	155	200	feature5	0	-</span>
<span class="sd">            chr1	1	100	feature1	0	+	chr1	800	901	feature6	0	+</span>
<span class="sd">            chr1	100	200	feature2	0	+	chr1	155	200	feature5	0	-</span>
<span class="sd">            chr1	100	200	feature2	0	+	chr1	800	901	feature6	0	+</span>
<span class="sd">            chr1	150	500	feature3	0	-	chr1	155	200	feature5	0	-</span>
<span class="sd">            chr1	150	500	feature3	0	-	chr1	800	901	feature6	0	+</span>
<span class="sd">            chr1	900	950	feature4	0	+	chr1	155	200	feature5	0	-</span>
<span class="sd">            chr1	900	950	feature4	0	+	chr1	800	901	feature6	0	+</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="BedTool.shuffle">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.shuffle.html#pybedtools.bedtool.BedTool.shuffle">[docs]</a>
    <span class="nd">@_log_to_history</span>
    <span class="nd">@_wraps</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s2">&quot;shuffleBed&quot;</span><span class="p">,</span> <span class="n">implicit</span><span class="o">=</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bam</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">uses_genome</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">shuffle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span> <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps `bedtools shuffle`.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; a = pybedtools.example_bedtool(&#39;a.bed&#39;)</span>
<span class="sd">        &gt;&gt;&gt; seed = 1 # so this test always returns the same results</span>
<span class="sd">        &gt;&gt;&gt; b = a.shuffle(genome=&#39;hg19&#39;, chrom=True, seed=seed)</span>
<span class="sd">        &gt;&gt;&gt; print(b) #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        chr1	123081365	123081464	feature1	0	+</span>
<span class="sd">        chr1	243444570	243444670	feature2	0	+</span>
<span class="sd">        chr1	194620241	194620591	feature3	0	-</span>
<span class="sd">        chr1	172792873	172792923	feature4	0	+</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="BedTool.sort">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.sort.html#pybedtools.bedtool.BedTool.sort">[docs]</a>
    <span class="nd">@_log_to_history</span>
    <span class="nd">@_wraps</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s2">&quot;sortBed&quot;</span><span class="p">,</span> <span class="n">implicit</span><span class="o">=</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="n">uses_genome</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">genome_if</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;g&quot;</span><span class="p">,</span> <span class="s2">&quot;genome&quot;</span><span class="p">])</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span> <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps `bedtools sort`.</span>

<span class="sd">        Note that chromosomes are sorted lexicographically, so chr12 will come</span>
<span class="sd">        before chr9.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; a = pybedtools.BedTool(&#39;&#39;&#39;</span>
<span class="sd">        ... chr9 300 400</span>
<span class="sd">        ... chr1 100 200</span>
<span class="sd">        ... chr1 1 50</span>
<span class="sd">        ... chr12 1 100</span>
<span class="sd">        ... chr9 500 600</span>
<span class="sd">        ... &#39;&#39;&#39;, from_string=True)</span>
<span class="sd">        &gt;&gt;&gt; print(a.sort()) #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        chr1	1	50</span>
<span class="sd">        chr1	100	200</span>
<span class="sd">        chr12	1	100</span>
<span class="sd">        chr9	300	400</span>
<span class="sd">        chr9	500	600</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="BedTool.annotate">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.annotate.html#pybedtools.bedtool.BedTool.annotate">[docs]</a>
    <span class="nd">@_log_to_history</span>
    <span class="nd">@_wraps</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s2">&quot;annotateBed&quot;</span><span class="p">,</span> <span class="n">implicit</span><span class="o">=</span><span class="s2">&quot;i&quot;</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">annotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span> <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps  `bedtools annotate`.</span>

<span class="sd">        Annotate this BedTool with a list of other files.</span>
<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; a = pybedtools.example_bedtool(&#39;a.bed&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b_fn = pybedtools.example_filename(&#39;b.bed&#39;)</span>
<span class="sd">        &gt;&gt;&gt; print(a.annotate(files=b_fn)) #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        chr1	1	100	feature1	0	+	0.000000</span>
<span class="sd">        chr1	100	200	feature2	0	+	0.450000</span>
<span class="sd">        chr1	150	500	feature3	0	-	0.128571</span>
<span class="sd">        chr1	900	950	feature4	0	+	0.020000</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="BedTool.flank">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.flank.html#pybedtools.bedtool.BedTool.flank">[docs]</a>
    <span class="nd">@_log_to_history</span>
    <span class="nd">@_wraps</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s2">&quot;flankBed&quot;</span><span class="p">,</span> <span class="n">implicit</span><span class="o">=</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="n">uses_genome</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">flank</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps `bedtools flank`.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; a = pybedtools.example_bedtool(&#39;a.bed&#39;)</span>
<span class="sd">        &gt;&gt;&gt; print(a.flank(genome=&#39;hg19&#39;, b=100)) #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        chr1	0	1	feature1	0	+</span>
<span class="sd">        chr1	100	200	feature1	0	+</span>
<span class="sd">        chr1	0	100	feature2	0	+</span>
<span class="sd">        chr1	200	300	feature2	0	+</span>
<span class="sd">        chr1	50	150	feature3	0	-</span>
<span class="sd">        chr1	500	600	feature3	0	-</span>
<span class="sd">        chr1	800	900	feature4	0	+</span>
<span class="sd">        chr1	950	1050	feature4	0	+</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_genome</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;i&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;i&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fn</span>

        <span class="n">cmds</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">stdin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_kwargs</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s2">&quot;flankBed&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">stream</span> <span class="o">=</span> <span class="n">call_bedtools</span><span class="p">(</span><span class="n">cmds</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">stdin</span><span class="o">=</span><span class="n">stdin</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BedTool</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span></div>


<div class="viewcode-block" id="BedTool.genome_coverage">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.genome_coverage.html#pybedtools.bedtool.BedTool.genome_coverage">[docs]</a>
    <span class="nd">@_log_to_history</span>
    <span class="nd">@_wraps</span><span class="p">(</span>
        <span class="n">prog</span><span class="o">=</span><span class="s2">&quot;genomeCoverageBed&quot;</span><span class="p">,</span>
        <span class="n">implicit</span><span class="o">=</span><span class="s2">&quot;i&quot;</span><span class="p">,</span>
        <span class="n">bam</span><span class="o">=</span><span class="s2">&quot;ibam&quot;</span><span class="p">,</span>
        <span class="n">genome_none_if</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;ibam&quot;</span><span class="p">],</span>
        <span class="n">genome_ok_if</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;ibam&quot;</span><span class="p">],</span>
        <span class="n">uses_genome</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">nonbam</span><span class="o">=</span><span class="s2">&quot;ALL&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">genome_coverage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps `bedtools genomecov`.</span>

<span class="sd">        Note that some invocations of `bedtools genomecov` do not result in</span>
<span class="sd">        a properly-formatted BED file. For example, the default behavior is to</span>
<span class="sd">        report a histogram of coverage. Iterating over the resulting,</span>
<span class="sd">        non-BED-format file will raise exceptions in pybedtools&#39; parser.</span>

<span class="sd">        Consider using the `BedTool.to_dataframe` method to convert these</span>
<span class="sd">        non-BED files into a pandas DataFrame for further use.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        BAM file input does not require a genome:</span>

<span class="sd">        &gt;&gt;&gt; a = pybedtools.example_bedtool(&#39;x.bam&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b = a.genome_coverage(bg=True)</span>
<span class="sd">        &gt;&gt;&gt; b.head(3) #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        chr2L	9329	9365	1</span>
<span class="sd">        chr2L	10212	10248	1</span>
<span class="sd">        chr2L	10255	10291	1</span>

<span class="sd">        Other input does require a genome:</span>

<span class="sd">        &gt;&gt;&gt; a = pybedtools.example_bedtool(&#39;x.bed&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b = a.genome_coverage(bg=True, genome=&#39;dm3&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b.head(3) #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        chr2L	9329	9365	1</span>
<span class="sd">        chr2L	10212	10248	1</span>
<span class="sd">        chr2L	10255	10291	1</span>

<span class="sd">        Non-BED format results:</span>
<span class="sd">        &gt;&gt;&gt; a = pybedtools.example_bedtool(&#39;x.bed&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b = a.genome_coverage(genome=&#39;dm3&#39;)</span>
<span class="sd">        &gt;&gt;&gt; df = b.to_dataframe(names=[&#39;chrom&#39;, &#39;depth&#39;, &#39;n&#39;, &#39;chromsize&#39;, &#39;fraction&#39;])</span>
<span class="sd">        &quot;&quot;&quot;</span></div>


    <span class="c1"># Alias for backwards compatibility</span>
    <span class="n">genomecov</span> <span class="o">=</span> <span class="n">genome_coverage</span>

<div class="viewcode-block" id="BedTool.coverage">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.coverage.html#pybedtools.bedtool.BedTool.coverage">[docs]</a>
    <span class="nd">@_log_to_history</span>
    <span class="nd">@_wraps</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s2">&quot;coverageBed&quot;</span><span class="p">,</span> <span class="n">implicit</span><span class="o">=</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">bam</span><span class="o">=</span><span class="s2">&quot;abam&quot;</span><span class="p">,</span> <span class="n">nonbam</span><span class="o">=</span><span class="s2">&quot;ALL&quot;</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">coverage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span> <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps `bedtools coverage`.</span>

<span class="sd">        Note that starting in version 2.24.0, BEDTools swapped the semantics of</span>
<span class="sd">        the &quot;a&quot; and &quot;b&quot; files.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; a = pybedtools.example_bedtool(&#39;a.bed&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b = pybedtools.example_bedtool(&#39;b.bed&#39;)</span>
<span class="sd">        &gt;&gt;&gt; c = b.coverage(a)</span>
<span class="sd">        &gt;&gt;&gt; c.head(3) #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        chr1	155	200	feature5	0	-	2	45	45	1.0000000</span>
<span class="sd">        chr1	800	901	feature6	0	+	1	1	101	0.0099010</span>
<span class="sd">        &quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="BedTool.mask_fasta">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.mask_fasta.html#pybedtools.bedtool.BedTool.mask_fasta">[docs]</a>
    <span class="nd">@_log_to_history</span>
    <span class="nd">@_wraps</span><span class="p">(</span>
        <span class="n">prog</span><span class="o">=</span><span class="s2">&quot;maskFastaFromBed&quot;</span><span class="p">,</span>
        <span class="n">implicit</span><span class="o">=</span><span class="s2">&quot;bed&quot;</span><span class="p">,</span>
        <span class="n">other</span><span class="o">=</span><span class="s2">&quot;fi&quot;</span><span class="p">,</span>
        <span class="n">make_tempfile_for</span><span class="o">=</span><span class="s2">&quot;fo&quot;</span><span class="p">,</span>
        <span class="n">add_to_bedtool</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;fo&quot;</span><span class="p">:</span> <span class="s2">&quot;seqfn&quot;</span><span class="p">},</span>
        <span class="n">check_stderr</span><span class="o">=</span><span class="n">_check_sequence_stderr</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">mask_fasta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span> <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps `bedtools maskfasta`.</span>

<span class="sd">        Masks a fasta file at the positions in a BED file and saves result as</span>
<span class="sd">        &#39;out&#39; and stores the filename in seqfn.</span>

<span class="sd">        &gt;&gt;&gt; a = pybedtools.BedTool(&#39;chr1 100 110&#39;, from_string=True)</span>
<span class="sd">        &gt;&gt;&gt; fasta_fn = pybedtools.example_filename(&#39;test.fa&#39;)</span>
<span class="sd">        &gt;&gt;&gt; a = a.mask_fasta(fi=fasta_fn, fo=&#39;masked.fa.example&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b = a.slop(b=2, genome=&#39;hg19&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b = b.sequence(fi=a.seqfn)</span>
<span class="sd">        &gt;&gt;&gt; print(open(b.seqfn).read())</span>
<span class="sd">        &gt;chr1:98-112</span>
<span class="sd">        TTNNNNNNNNNNAT</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        &gt;&gt;&gt; os.unlink(&#39;masked.fa.example&#39;)</span>
<span class="sd">        &gt;&gt;&gt; if os.path.exists(&#39;masked.fa.example.fai&#39;):</span>
<span class="sd">        ...     os.unlink(&#39;masked.fa.example.fai&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span></div>


    <span class="c1"># Alias for backwards compatibility</span>
    <span class="n">maskfasta</span> <span class="o">=</span> <span class="n">mask_fasta</span>

<div class="viewcode-block" id="BedTool.complement">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.complement.html#pybedtools.bedtool.BedTool.complement">[docs]</a>
    <span class="nd">@_log_to_history</span>
    <span class="nd">@_wraps</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s2">&quot;complementBed&quot;</span><span class="p">,</span> <span class="n">implicit</span><span class="o">=</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="n">uses_genome</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">complement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span> <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps `bedtools complement`.</span>
<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; a = pybedtools.example_bedtool(&#39;a.bed&#39;)</span>
<span class="sd">        &gt;&gt;&gt; a.complement(genome=&#39;hg19&#39;).head(5) #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        chr1	0	1</span>
<span class="sd">        chr1	500	900</span>
<span class="sd">        chr1	950	249250621</span>
<span class="sd">        chr2	0	243199373</span>
<span class="sd">        chr3	0	198022430</span>
<span class="sd">        &quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="BedTool.overlap">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.overlap.html#pybedtools.bedtool.BedTool.overlap">[docs]</a>
    <span class="nd">@_log_to_history</span>
    <span class="nd">@_wraps</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s2">&quot;getOverlap&quot;</span><span class="p">,</span> <span class="n">implicit</span><span class="o">=</span><span class="s2">&quot;i&quot;</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">overlap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span> <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps `bedtools overlap`.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; a = pybedtools.example_bedtool(&#39;a.bed&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b = pybedtools.example_bedtool(&#39;b.bed&#39;)</span>
<span class="sd">        &gt;&gt;&gt; c = a.window(b, w=10).overlap(cols=[2,3,8,9])</span>
<span class="sd">        &gt;&gt;&gt; print(c) #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        chr1	100	200	feature2	0	+	chr1	155	200	feature5	0	-	45</span>
<span class="sd">        chr1	150	500	feature3	0	-	chr1	155	200	feature5	0	-	45</span>
<span class="sd">        chr1	900	950	feature4	0	+	chr1	800	901	feature6	0	+	1</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span></div>


    <span class="c1"># TODO: needs test files and doctests written</span>
<div class="viewcode-block" id="BedTool.pair_to_bed">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.pair_to_bed.html#pybedtools.bedtool.BedTool.pair_to_bed">[docs]</a>
    <span class="nd">@_log_to_history</span>
    <span class="nd">@_wraps</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s2">&quot;pairToBed&quot;</span><span class="p">,</span> <span class="n">implicit</span><span class="o">=</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">bam</span><span class="o">=</span><span class="s2">&quot;abam&quot;</span><span class="p">,</span> <span class="n">nonbam</span><span class="o">=</span><span class="s2">&quot;bedpe&quot;</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">pair_to_bed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span> <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps `bedtools pairtobed`.</span>
<span class="sd">        &quot;&quot;&quot;</span></div>


    <span class="c1"># Alias for backwards compatibility</span>
    <span class="n">pairtobed</span> <span class="o">=</span> <span class="n">pair_to_bed</span>

<div class="viewcode-block" id="BedTool.pair_to_pair">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.pair_to_pair.html#pybedtools.bedtool.BedTool.pair_to_pair">[docs]</a>
    <span class="nd">@_log_to_history</span>
    <span class="nd">@_wraps</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s2">&quot;pairToPair&quot;</span><span class="p">,</span> <span class="n">implicit</span><span class="o">=</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">pair_to_pair</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span> <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps `bedtools pairtopair`.</span>
<span class="sd">        &quot;&quot;&quot;</span></div>


    <span class="c1"># Alias for backwards compatibility</span>
    <span class="n">pairtopair</span> <span class="o">=</span> <span class="n">pair_to_pair</span>

<div class="viewcode-block" id="BedTool.groupby">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.groupby.html#pybedtools.bedtool.BedTool.groupby">[docs]</a>
    <span class="nd">@_log_to_history</span>
    <span class="nd">@_wraps</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s2">&quot;groupBy&quot;</span><span class="p">,</span> <span class="n">implicit</span><span class="o">=</span><span class="s2">&quot;i&quot;</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">groupby</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps `bedtools groupby`.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; a = pybedtools.example_bedtool(&#39;gdc.gff&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b = pybedtools.example_bedtool(&#39;gdc.bed&#39;)</span>
<span class="sd">        &gt;&gt;&gt; c = a.intersect(b, c=True)</span>
<span class="sd">        &gt;&gt;&gt; d = c.groupby(g=[1, 4, 5], c=10, o=[&#39;sum&#39;])</span>
<span class="sd">        &gt;&gt;&gt; print(d) #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        chr2L	41	70	0</span>
<span class="sd">        chr2L	71	130	2</span>
<span class="sd">        chr2L	131	170	4</span>
<span class="sd">        chr2L	171	200	0</span>
<span class="sd">        chr2L	201	220	1</span>
<span class="sd">        chr2L	41	130	2</span>
<span class="sd">        chr2L	171	220	1</span>
<span class="sd">        chr2L	41	220	7</span>
<span class="sd">        chr2L	161	230	6</span>
<span class="sd">        chr2L	41	220	7</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>

<span class="sd">        &quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="BedTool.tag_bam">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.tag_bam.html#pybedtools.bedtool.BedTool.tag_bam">[docs]</a>
    <span class="nd">@_log_to_history</span>
    <span class="nd">@_wraps</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s2">&quot;tagBam&quot;</span><span class="p">,</span> <span class="n">implicit</span><span class="o">=</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="n">bam</span><span class="o">=</span><span class="s2">&quot;i&quot;</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">tag_bam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pysam</span><span class="o">.</span><span class="n">AlignmentFile</span><span class="p">:</span> <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps `bedtools tag`.</span>

<span class="sd">        `files` and `labels` should lists of equal length.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;i&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;labels&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;i&quot;</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;labels&quot;</span><span class="p">]):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;files and labels must be lists of equal length&quot;</span><span class="p">)</span></div>



    <span class="c1"># Alias for backwards compatibility</span>
    <span class="n">tag</span> <span class="o">=</span> <span class="n">tag_bam</span>

<div class="viewcode-block" id="BedTool.map">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.map.html#pybedtools.bedtool.BedTool.map">[docs]</a>
    <span class="nd">@_log_to_history</span>
    <span class="nd">@_wraps</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s2">&quot;mapBed&quot;</span><span class="p">,</span> <span class="n">implicit</span><span class="o">=</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span> <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps  `bedtools map`; See also :meth:`BedTool.each`.</span>
<span class="sd">        &quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="BedTool.multi_intersect">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.multi_intersect.html#pybedtools.bedtool.BedTool.multi_intersect">[docs]</a>
    <span class="nd">@_log_to_history</span>
    <span class="nd">@_wraps</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s2">&quot;multiIntersectBed&quot;</span><span class="p">,</span> <span class="n">uses_genome</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">genome_if</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;empty&quot;</span><span class="p">])</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">multi_intersect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span> <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps `bedtools multiintersect`.</span>

<span class="sd">        Provide a list of filenames as the &quot;i&quot; argument. e.g. if you already</span>
<span class="sd">        have BedTool objects then use their `.fn` attribute, like this::</span>

<span class="sd">            &gt;&gt;&gt; x = pybedtools.BedTool()</span>
<span class="sd">            &gt;&gt;&gt; a = pybedtools.example_bedtool(&#39;a.bed&#39;)</span>
<span class="sd">            &gt;&gt;&gt; b = pybedtools.example_bedtool(&#39;b.bed&#39;)</span>
<span class="sd">            &gt;&gt;&gt; result = x.multi_intersect(i=[a.fn, b.fn])</span>
<span class="sd">            &gt;&gt;&gt; print(result)   #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">            chr1	1	155	1	1	1	0</span>
<span class="sd">            chr1	155	200	2	1,2	1	1</span>
<span class="sd">            chr1	200	500	1	1	1	0</span>
<span class="sd">            chr1	800	900	1	2	0	1</span>
<span class="sd">            chr1	900	901	2	1,2	1	1</span>
<span class="sd">            chr1	901	950	1	1	1	0</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>

<span class="sd">        &quot;&quot;&quot;</span></div>


    <span class="c1"># Alias for backwards compatibility</span>
    <span class="n">multiinter</span> <span class="o">=</span> <span class="n">multi_intersect</span>

<div class="viewcode-block" id="BedTool.random">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.random.html#pybedtools.bedtool.BedTool.random">[docs]</a>
    <span class="nd">@_log_to_history</span>
    <span class="nd">@_wraps</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s2">&quot;randomBed&quot;</span><span class="p">,</span> <span class="n">uses_genome</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">random</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span> <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps `bedtools random`.</span>

<span class="sd">        Since this method does not operate on an existing file, create</span>
<span class="sd">        a BedTool with no arguments and then call this method, e.g.,</span>

<span class="sd">        &gt;&gt;&gt; x = BedTool()</span>
<span class="sd">        &gt;&gt;&gt; y = x.random(l=100, n=10, genome=&#39;hg19&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="BedTool.bedpe_to_bam">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.bedpe_to_bam.html#pybedtools.bedtool.BedTool.bedpe_to_bam">[docs]</a>
    <span class="nd">@_log_to_history</span>
    <span class="nd">@_wraps</span><span class="p">(</span><span class="s2">&quot;bedpeToBam&quot;</span><span class="p">,</span> <span class="n">implicit</span><span class="o">=</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="n">uses_genome</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">force_bam</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">bedpe_to_bam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pysam</span><span class="o">.</span><span class="n">AlignmentFile</span><span class="p">:</span> <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps `bedtools bedpetobam`.</span>
<span class="sd">        &quot;&quot;&quot;</span></div>


    <span class="c1"># Alias for backwards compatibility</span>
    <span class="n">bedpetobam</span> <span class="o">=</span> <span class="n">bedpe_to_bam</span>

<div class="viewcode-block" id="BedTool.cluster">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.cluster.html#pybedtools.bedtool.BedTool.cluster">[docs]</a>
    <span class="nd">@_log_to_history</span>
    <span class="nd">@_wraps</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s2">&quot;clusterBed&quot;</span><span class="p">,</span> <span class="n">implicit</span><span class="o">=</span><span class="s2">&quot;i&quot;</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">cluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span> <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps  `bedtools cluster`.</span>
<span class="sd">        &quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="BedTool.union_bedgraphs">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.union_bedgraphs.html#pybedtools.bedtool.BedTool.union_bedgraphs">[docs]</a>
    <span class="nd">@_log_to_history</span>
    <span class="nd">@_wraps</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s2">&quot;unionBedGraphs&quot;</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">union_bedgraphs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span> <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps `bedtools unionbedg`.</span>

<span class="sd">        Warning: using the `header=True` kwarg will result in a file that is</span>
<span class="sd">        not in true BED format, which may break downstream analysis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;header&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;header&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Using header=True with unionbedg will result in a file that is not in true BED format, which may break downstream analysis.&quot;</span><span class="p">)</span></div>



    <span class="c1"># Alias for backwards compatibility</span>
    <span class="n">unionbedg</span> <span class="o">=</span> <span class="n">union_bedgraphs</span>

<div class="viewcode-block" id="BedTool.window_maker">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.window_maker.html#pybedtools.bedtool.BedTool.window_maker">[docs]</a>
    <span class="nd">@_log_to_history</span>
    <span class="nd">@_wraps</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s2">&quot;windowMaker&quot;</span><span class="p">,</span> <span class="n">uses_genome</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">genome_none_if</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;b&quot;</span><span class="p">],</span> <span class="n">other</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">arg_order</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;w&quot;</span><span class="p">])</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">window_maker</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span> <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps `bedtools makewindows`.</span>
<span class="sd">        &quot;&quot;&quot;</span></div>


    <span class="c1"># Alias for backwards compatibility</span>
    <span class="n">makewindows</span> <span class="o">=</span> <span class="n">window_maker</span>

<div class="viewcode-block" id="BedTool.expand">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.expand.html#pybedtools.bedtool.BedTool.expand">[docs]</a>
    <span class="nd">@_log_to_history</span>
    <span class="nd">@_wraps</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s2">&quot;expandCols&quot;</span><span class="p">,</span> <span class="n">implicit</span><span class="o">=</span><span class="s2">&quot;i&quot;</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">expand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span> <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps `bedtools expand`</span>
<span class="sd">        &quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="BedTool.links">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.links.html#pybedtools.bedtool.BedTool.links">[docs]</a>
    <span class="nd">@_log_to_history</span>
    <span class="nd">@_wraps</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s2">&quot;linksBed&quot;</span><span class="p">,</span> <span class="n">implicit</span><span class="o">=</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="n">add_to_bedtool</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;stdout&quot;</span><span class="p">:</span> <span class="s2">&quot;links_html&quot;</span><span class="p">})</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">links</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span> <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps `linksBed`.</span>

<span class="sd">        The resulting BedTool will assign a value to the attribute `links_html`.  This</span>
<span class="sd">        attribute is a temp filename containing the HTML links.</span>
<span class="sd">        &quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="BedTool.igv">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.igv.html#pybedtools.bedtool.BedTool.igv">[docs]</a>
    <span class="nd">@_log_to_history</span>
    <span class="nd">@_wraps</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s2">&quot;bedToIgv&quot;</span><span class="p">,</span> <span class="n">implicit</span><span class="o">=</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="n">add_to_bedtool</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;stdout&quot;</span><span class="p">:</span> <span class="s2">&quot;igv_script&quot;</span><span class="p">})</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">igv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span> <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps `bedtools igv`.</span>

<span class="sd">        The resulting BedTool will assign a value to the attribute `igv_script`.  This</span>
<span class="sd">        attribute is a temp filename containing the IGV script.</span>
<span class="sd">        &quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="BedTool.bam_to_fastq">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.bam_to_fastq.html#pybedtools.bedtool.BedTool.bam_to_fastq">[docs]</a>
    <span class="nd">@_log_to_history</span>
    <span class="nd">@_wraps</span><span class="p">(</span>
        <span class="n">prog</span><span class="o">=</span><span class="s2">&quot;bamToFastq&quot;</span><span class="p">,</span>
        <span class="n">implicit</span><span class="o">=</span><span class="s2">&quot;i&quot;</span><span class="p">,</span>
        <span class="n">bam</span><span class="o">=</span><span class="s2">&quot;i&quot;</span><span class="p">,</span>
        <span class="n">make_tempfile_for</span><span class="o">=</span><span class="s2">&quot;fq&quot;</span><span class="p">,</span>
        <span class="n">add_to_bedtool</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;fq&quot;</span><span class="p">:</span> <span class="s2">&quot;fastq&quot;</span><span class="p">},</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">bam_to_fastq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span> <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps `bedtools bamtofastq`.</span>

<span class="sd">        The `fq` argument is required.</span>

<span class="sd">        The resulting BedTool will assign a value to the attribute `fastq`.</span>
<span class="sd">        &quot;&quot;&quot;</span></div>


    <span class="c1"># Alias for backwards compatibility</span>
    <span class="n">bamtofastq</span> <span class="o">=</span> <span class="n">bam_to_fastq</span>

<div class="viewcode-block" id="BedTool.jaccard">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.jaccard.html#pybedtools.bedtool.BedTool.jaccard">[docs]</a>
    <span class="nd">@_wraps</span><span class="p">(</span>
        <span class="n">prog</span><span class="o">=</span><span class="s2">&quot;jaccard&quot;</span><span class="p">,</span>
        <span class="n">implicit</span><span class="o">=</span><span class="s2">&quot;a&quot;</span><span class="p">,</span>
        <span class="n">other</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">,</span>
        <span class="n">does_not_return_bedtool</span><span class="o">=</span><span class="n">_jaccard_output_to_dict</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">jaccard</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span> <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dictionary with keys (intersection, union, jaccard).</span>
<span class="sd">        &quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="BedTool.reldist">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.reldist.html#pybedtools.bedtool.BedTool.reldist">[docs]</a>
    <span class="nd">@_wraps</span><span class="p">(</span>
        <span class="n">prog</span><span class="o">=</span><span class="s2">&quot;reldist&quot;</span><span class="p">,</span>
        <span class="n">implicit</span><span class="o">=</span><span class="s2">&quot;a&quot;</span><span class="p">,</span>
        <span class="n">other</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">,</span>
        <span class="n">does_not_return_bedtool</span><span class="o">=</span><span class="n">_reldist_output_handler</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">reldist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span> <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If detail=False, then return a dictionary with keys (reldist, count,</span>
<span class="sd">        total, fraction), which is the summary of the bedtools reldist.</span>

<span class="sd">        Otherwise return a BedTool, with the relative distance for each</span>
<span class="sd">        interval in A in the last column.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;detail&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;detail&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Using detail=False with reldist will return a dictionary with keys (reldist, count, total, fraction), which is the summary of the bedtools reldist.&quot;</span>
                     <span class="s2">&quot;Not a BedTool object.&quot;</span><span class="p">)</span></div>



    <span class="nd">@_wraps</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s2">&quot;sample&quot;</span><span class="p">,</span> <span class="n">implicit</span><span class="o">=</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="n">bam</span><span class="o">=</span><span class="s2">&quot;i&quot;</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span> <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps &#39;sample&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="nd">@_wraps</span><span class="p">(</span>
        <span class="n">prog</span><span class="o">=</span><span class="s2">&quot;fisher&quot;</span><span class="p">,</span>
        <span class="n">implicit</span><span class="o">=</span><span class="s2">&quot;a&quot;</span><span class="p">,</span>
        <span class="n">other</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">,</span>
        <span class="n">uses_genome</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">does_not_return_bedtool</span><span class="o">=</span><span class="n">FisherOutput</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">fisher</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FisherOutput</span><span class="p">:</span> <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps &#39;fisher&#39;. Returns an object representing the output.</span>

<span class="sd">        &gt;&gt;&gt; a = pybedtools.example_bedtool(&#39;a.bed&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b = pybedtools.example_bedtool(&#39;b.bed&#39;)</span>
<span class="sd">        &gt;&gt;&gt; f = a.fisher(b, genome=&#39;hg19&#39;)</span>
<span class="sd">        &gt;&gt;&gt; print(f)  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        # Number of query intervals: 4</span>
<span class="sd">        # Number of db intervals: 2</span>
<span class="sd">        # Number of overlaps: 3</span>
<span class="sd">        # Number of possible intervals (estimated): 13958448</span>
<span class="sd">        # phyper(3 - 1, 4, 13958448 - 4, 2, lower.tail=F)</span>
<span class="sd">        # Contingency Table Of Counts</span>
<span class="sd">        #_________________________________________</span>
<span class="sd">        #           |  in -b       | not in -b    |</span>
<span class="sd">        #     in -a | 3            | 1            |</span>
<span class="sd">        # not in -a | 0            | 13958444     |</span>
<span class="sd">        #_________________________________________</span>
<span class="sd">        # p-values for fisher&#39;s exact test</span>
<span class="sd">        left	right	two-tail	ratio</span>
<span class="sd">        1	8.8247e-21	8.8247e-21	inf</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>


<span class="sd">        &gt;&gt;&gt; f.table[&#39;not in -a&#39;][&#39;in -b&#39;]</span>
<span class="sd">        0</span>

<span class="sd">        &gt;&gt;&gt; f.table[&#39;not in -a&#39;][&#39;not in -b&#39;]</span>
<span class="sd">        13958444</span>

<span class="sd">        &gt;&gt;&gt; f.table[&#39;in -a&#39;][&#39;in -b&#39;]</span>
<span class="sd">        3</span>

<span class="sd">        &gt;&gt;&gt; f.table[&#39;in -a&#39;][&#39;not in -b&#39;]</span>
<span class="sd">        1</span>

<span class="sd">        &gt;&gt;&gt; f.two_tail</span>
<span class="sd">        8.8247e-21</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="nd">@_wraps</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s2">&quot;split&quot;</span><span class="p">,</span> <span class="n">implicit</span><span class="o">=</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="n">does_not_return_bedtool</span><span class="o">=</span><span class="n">SplitOutput</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">splitbed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SplitOutput</span><span class="p">:</span>  <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps &#39;bedtools split&#39;.</span>

<span class="sd">        BedTool objects have long had a `split` method which splits intervals</span>
<span class="sd">        according to a custom function. Now that BEDTools has a `split` tool,</span>
<span class="sd">        the method name conflicts. To maintain backwards compatibility, the</span>
<span class="sd">        method wrapping the BEDTools command is called `splitbed`.</span>

<span class="sd">        Since this tool does not return a single BED file, the method parses</span>
<span class="sd">        the output and returns a SplitOutput object, which includes an</span>
<span class="sd">        attribute, `bedtools`, that is a list of BedTool objects created from</span>
<span class="sd">        the split files.</span>

<span class="sd">        To keep the working directory clean, you may want to consider using</span>
<span class="sd">        `prefix=BedTool._tmp()` to get a temp file that will be deleted when</span>
<span class="sd">        Python exits cleanly.</span>

<span class="sd">        &gt;&gt;&gt; a = pybedtools.example_bedtool(&#39;a.bed&#39;)</span>
<span class="sd">        &gt;&gt;&gt; s = a.splitbed(n=2, p=&quot;split&quot;)</span>
<span class="sd">        &gt;&gt;&gt; assert len(a) == 4, len(a)</span>
<span class="sd">        &gt;&gt;&gt; assert len(s.bedtools) == 2</span>
<span class="sd">        &gt;&gt;&gt; print(s.bedtools[0]) # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        chr1	150	500	feature3	0	-</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        &gt;&gt;&gt; print(s.bedtools[1]) # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        chr1	100	200	feature2	0	+</span>
<span class="sd">        chr1	1	100	feature1	0	+</span>
<span class="sd">        chr1	900	950	feature4	0	+</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="nd">@_wraps</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s2">&quot;spacing&quot;</span><span class="p">,</span> <span class="n">implicit</span><span class="o">=</span><span class="s2">&quot;i&quot;</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">spacing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span>  <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps `bedtools spacing`</span>

<span class="sd">        &gt;&gt;&gt; a = pybedtools.example_bedtool(&#39;a.bed&#39;)</span>
<span class="sd">        &gt;&gt;&gt; print(a.spacing())  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        chr1	1	100	feature1	0	+	.</span>
<span class="sd">        chr1	100	200	feature2	0	+	0</span>
<span class="sd">        chr1	150	500	feature3	0	-	-1</span>
<span class="sd">        chr1	900	950	feature4	0	+	400</span>
<span class="sd">        &quot;&quot;&quot;</span>

<div class="viewcode-block" id="BedTool.count">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.count.html#pybedtools.bedtool.BedTool.count">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Count the number features in this BedTool.</span>

<span class="sd">        Number of features in BED file. Does the same thing as len(self), which</span>
<span class="sd">        actually just calls this method.</span>

<span class="sd">        Only counts the actual features.  Ignores any track lines, browser</span>
<span class="sd">        lines, lines starting with a &quot;#&quot;, or blank lines.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; a = pybedtools.example_bedtool(&#39;a.bed&#39;)</span>
<span class="sd">        &gt;&gt;&gt; a.count()</span>
<span class="sd">        4</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;next&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;__next__&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span></div>


<div class="viewcode-block" id="BedTool.print_sequence">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.print_sequence.html#pybedtools.bedtool.BedTool.print_sequence">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">print_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print the sequence that was retrieved by BedTool.sequence.</span>
<span class="sd">        See usage example in :meth:`BedTool.sequence`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: The sequence as a string.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the sequence has not been generated using .sequence(fasta).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">seqfn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Use .sequence(fasta) to get the sequence first&quot;</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seqfn</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">s</span></div>


<div class="viewcode-block" id="BedTool.save_seqs">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.save_seqs.html#pybedtools.bedtool.BedTool.save_seqs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">save_seqs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="p">:</span><span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save sequences, after calling BedTool.sequence.</span>

<span class="sd">        In order to use this function, you need to have called</span>
<span class="sd">        the :meth:`BedTool.sequence()` method.</span>

<span class="sd">        A new BedTool object is returned which references the newly saved file.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; a = pybedtools.BedTool(&#39;&#39;&#39;</span>
<span class="sd">        ... chr1 1 10</span>
<span class="sd">        ... chr1 50 55&#39;&#39;&#39;, from_string=True)</span>
<span class="sd">        &gt;&gt;&gt; fasta = pybedtools.example_filename(&#39;test.fa&#39;)</span>
<span class="sd">        &gt;&gt;&gt; a = a.sequence(fi=fasta)</span>
<span class="sd">        &gt;&gt;&gt; print(open(a.seqfn).read())</span>
<span class="sd">        &gt;chr1:1-10</span>
<span class="sd">        GATGAGTCT</span>
<span class="sd">        &gt;chr1:50-55</span>
<span class="sd">        CCATC</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        &gt;&gt;&gt; b = a.save_seqs(&#39;example.fa&#39;)</span>
<span class="sd">        &gt;&gt;&gt; assert open(b.fn).read() == open(a.fn).read()</span>
<span class="sd">        &gt;&gt;&gt; if os.path.exists(&#39;example.fa&#39;):</span>
<span class="sd">        ...     os.unlink(&#39;example.fa&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">seqfn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Use .sequence(fasta) to get the sequence first&quot;</span><span class="p">)</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fout</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">seqfn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Use .sequence(fasta) to get the sequence first&quot;</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seqfn</span><span class="p">)</span> <span class="k">as</span> <span class="n">seqfile</span><span class="p">:</span>
                <span class="n">fout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">seqfile</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>

        <span class="n">new_bedtool</span> <span class="o">=</span> <span class="n">BedTool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">)</span>
        <span class="n">new_bedtool</span><span class="o">.</span><span class="n">seqfn</span> <span class="o">=</span> <span class="n">fn</span>
        <span class="k">return</span> <span class="n">new_bedtool</span></div>


<div class="viewcode-block" id="BedTool.randomstats">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.randomstats.html#pybedtools.bedtool.BedTool.randomstats">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">randomstats</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="n">BedTool</span><span class="p">,</span>
        <span class="n">iterations</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">new</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">genome_fn</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">include_distribution</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Dictionary of results from many randomly shuffled intersections.</span>

<span class="sd">        Sends args and kwargs to :meth:`BedTool.randomintersection` and</span>
<span class="sd">        compiles results into a dictionary with useful stats.  Requires</span>
<span class="sd">        numpy.</span>

<span class="sd">        If `include_distribution` is True, then the dictionary will include the</span>
<span class="sd">        full distribution; otherwise, the distribution is deleted and cleaned</span>
<span class="sd">        up to save on memory usage.</span>

<span class="sd">        This is one possible way of assigning significance to overlaps between</span>
<span class="sd">        two files. See, for example:</span>

<span class="sd">            Negre N, Brown CD, Shah PK, Kheradpour P, Morrison CA, et al. 2010</span>
<span class="sd">            A Comprehensive Map of Insulator Elements for the Drosophila</span>
<span class="sd">            Genome. PLoS Genet 6(1): e1000814. doi:10.1371/journal.pgen.1000814</span>

<span class="sd">        Example usage:</span>

<span class="sd">        Make chromsizes a very small genome for this example:</span>

<span class="sd">        &gt;&gt;&gt; chromsizes = {&#39;chr1&#39;:(1,1000)}</span>
<span class="sd">        &gt;&gt;&gt; a = pybedtools.example_bedtool(&#39;a.bed&#39;).set_chromsizes(chromsizes)</span>
<span class="sd">        &gt;&gt;&gt; b = pybedtools.example_bedtool(&#39;b.bed&#39;)</span>
<span class="sd">        &gt;&gt;&gt; try:</span>
<span class="sd">        ...     results = a.randomstats(b, 100, debug=True)</span>
<span class="sd">        ... except ImportError:</span>
<span class="sd">        ...     pass</span>

<span class="sd">        *results* is a dictionary that you can inspect.</span>

<span class="sd">        (Note that the following examples are not run as part of the doctests</span>
<span class="sd">        to avoid forcing users to install NumPy just to pass tests)</span>

<span class="sd">        The actual overlap::</span>

<span class="sd">            print(results[&#39;actual&#39;])</span>
<span class="sd">            3</span>

<span class="sd">        The median of all randomized overlaps::</span>

<span class="sd">            print(results[&#39;median randomized&#39;])</span>
<span class="sd">            2.0</span>

<span class="sd">        The percentile of the actual overlap in the distribution of randomized</span>
<span class="sd">        overlaps, which can be used to get an empirical p-value::</span>

<span class="sd">            print(results[&#39;percentile&#39;])</span>
<span class="sd">            90.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;intersect_kwargs&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;intersect_kwargs&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;intersect_kwargs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;u&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;Need to install NumPy for stats...&quot;</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">percentileofscore</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">score</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            copied from scipy.stats.percentileofscore, to avoid dependency on</span>
<span class="sd">            scipy.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">score</span><span class="p">)):</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">score</span><span class="p">)</span>
                <span class="n">a_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">a_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))))</span> <span class="o">+</span> <span class="mf">1.0</span>

            <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">a</span> <span class="o">==</span> <span class="n">score</span><span class="p">])</span>
            <span class="n">pct</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">a_len</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="o">/</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="mf">100.0</span>
            <span class="k">return</span> <span class="n">pct</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">BedTool</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">other</span><span class="p">,</span> <span class="n">BedTool</span>
            <span class="p">),</span> <span class="s2">&quot;Either filename or another BedTool instance required&quot;</span>

        <span class="c1"># Actual (unshuffled) counts.</span>
        <span class="n">i_kwargs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;intersect_kwargs&quot;</span><span class="p">]</span>
        <span class="n">actual</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">i_kwargs</span><span class="p">))</span>

        <span class="c1"># List of counts from randomly shuffled versions.</span>
        <span class="c1"># Length of counts == *iterations*.</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">new</span><span class="p">:</span>
            <span class="n">distribution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">randomintersection</span><span class="p">(</span>
                <span class="n">other</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="n">iterations</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># use new mechanism</span>
            <span class="k">if</span> <span class="n">genome_fn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;`genome_fn` must be provided if using the &quot;</span>
                    <span class="s2">&quot;new _randomintersection mechanism&quot;</span>
                <span class="p">)</span>
            <span class="n">distribution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_randomintersection</span><span class="p">(</span>
                <span class="n">other</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="n">iterations</span><span class="p">,</span> <span class="n">genome_fn</span><span class="o">=</span><span class="n">genome_fn</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>

        <span class="n">distribution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">distribution</span><span class="p">))</span>

        <span class="c1"># Median of distribution</span>
        <span class="n">med_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">distribution</span><span class="p">)</span>

        <span class="n">n</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">distribution</span><span class="p">))</span>

        <span class="n">frac_above</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">distribution</span> <span class="o">&gt;</span> <span class="n">actual</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span>
        <span class="n">frac_below</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">distribution</span> <span class="o">&lt;</span> <span class="n">actual</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span>

        <span class="n">normalized</span> <span class="o">=</span> <span class="n">actual</span> <span class="o">/</span> <span class="n">med_count</span>

        <span class="n">lower_thresh</span> <span class="o">=</span> <span class="mf">2.5</span>
        <span class="n">upper_thresh</span> <span class="o">=</span> <span class="mf">97.5</span>
        <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">distribution</span><span class="p">,</span> <span class="p">[</span><span class="n">lower_thresh</span><span class="p">,</span> <span class="n">upper_thresh</span><span class="p">])</span>

        <span class="n">actual_percentile</span> <span class="o">=</span> <span class="n">percentileofscore</span><span class="p">(</span><span class="n">distribution</span><span class="p">,</span> <span class="n">actual</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;iterations&quot;</span><span class="p">:</span> <span class="n">iterations</span><span class="p">,</span>
            <span class="s2">&quot;actual&quot;</span><span class="p">:</span> <span class="n">actual</span><span class="p">,</span>
            <span class="s2">&quot;file_a&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">,</span>
            <span class="s2">&quot;file_b&quot;</span><span class="p">:</span> <span class="n">other</span><span class="o">.</span><span class="n">fn</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
            <span class="n">other</span><span class="o">.</span><span class="n">fn</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">),</span>
            <span class="s2">&quot;self&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
            <span class="s2">&quot;other&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">),</span>
            <span class="s2">&quot;frac randomized above actual&quot;</span><span class="p">:</span> <span class="n">frac_above</span><span class="p">,</span>
            <span class="s2">&quot;frac randomized below actual&quot;</span><span class="p">:</span> <span class="n">frac_below</span><span class="p">,</span>
            <span class="s2">&quot;median randomized&quot;</span><span class="p">:</span> <span class="n">med_count</span><span class="p">,</span>
            <span class="s2">&quot;normalized&quot;</span><span class="p">:</span> <span class="n">normalized</span><span class="p">,</span>
            <span class="s2">&quot;percentile&quot;</span><span class="p">:</span> <span class="n">actual_percentile</span><span class="p">,</span>
            <span class="s2">&quot;lower_</span><span class="si">%s</span><span class="s2">th&quot;</span> <span class="o">%</span> <span class="n">lower_thresh</span><span class="p">:</span> <span class="n">lower</span><span class="p">,</span>
            <span class="s2">&quot;upper_</span><span class="si">%s</span><span class="s2">th&quot;</span> <span class="o">%</span> <span class="n">upper_thresh</span><span class="p">:</span> <span class="n">upper</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">include_distribution</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;distribution&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">distribution</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">distribution</span>
        <span class="k">return</span> <span class="n">d</span></div>


<div class="viewcode-block" id="BedTool.random_op">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.random_op.html#pybedtools.bedtool.BedTool.random_op">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">random_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For backwards compatibility; see BedTool.parallel_apply instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parallel_apply</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="BedTool.parallel_apply">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.parallel_apply.html#pybedtools.bedtool.BedTool.parallel_apply">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">parallel_apply</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">iterations</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
        <span class="n">func_args</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">,</span>
        <span class="n">func_kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
        <span class="n">processes</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">_orig_pool</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Pool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: ignore</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generalized method for applying a function in parallel.</span>

<span class="sd">        Typically used when having to do many random shufflings.</span>

<span class="sd">        `func_args` and `func_kwargs` will be passed to `func` each time in</span>
<span class="sd">        `iterations`, and these iterations will be split across `processes`</span>
<span class="sd">        processes.</span>

<span class="sd">        Notes on the function, `func`:</span>

<span class="sd">            * the function should manually remove any tempfiles created.  This</span>
<span class="sd">              is because the BedTool.TEMPFILES list of auto-created tempfiles</span>
<span class="sd">              does not share state across processes, so things will not get</span>
<span class="sd">              cleaned up automatically as they do in a single-process</span>
<span class="sd">              pybedtools session.</span>

<span class="sd">            * this includes deleting any &quot;chromsizes&quot; or genome files --</span>
<span class="sd">              generally it will be best to require a genome filename in</span>
<span class="sd">              `func_kwargs` if you&#39;ll be using any BedTool methods that accept</span>
<span class="sd">              the `g` kwarg.</span>

<span class="sd">            * the function should be a module-level function (rather than a</span>
<span class="sd">              class method) because class methods can&#39;t be pickled across</span>
<span class="sd">              process boundaries</span>

<span class="sd">            * the function can have any signature and have any return value</span>

<span class="sd">        `_orig_pool` can be a previously-created multiprocessing.Pool instance;</span>
<span class="sd">        otherwise, a new Pool will be created with `processes`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">processes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iterations</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">func_args</span><span class="p">,</span> <span class="o">**</span><span class="n">func_kwargs</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span>

        <span class="k">if</span> <span class="n">_orig_pool</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">_orig_pool</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="p">)</span>
        <span class="n">iterations_each</span> <span class="o">=</span> <span class="p">[</span><span class="n">iterations</span> <span class="o">/</span> <span class="n">processes</span><span class="p">]</span> <span class="o">*</span> <span class="n">processes</span>
        <span class="n">iterations_each</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">iterations</span> <span class="o">%</span> <span class="n">processes</span>

        <span class="c1"># FYI some useful info on apply_async:</span>
        <span class="c1"># http://stackoverflow.com/questions/8533318/</span>
        <span class="c1">#      python-multiprocessing-pool-when-to-use-apply-apply-async-or-map</span>
        <span class="c1">#</span>
        <span class="c1"># Here, we don&#39;t care about the order, and don&#39;t want the subprocesses</span>
        <span class="c1"># to block.</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">p</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">func_args</span><span class="p">,</span> <span class="n">func_kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iterations</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">r</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="k">raise</span> <span class="ne">StopIteration</span></div>


<div class="viewcode-block" id="BedTool.random_jaccard">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.random_jaccard.html#pybedtools.bedtool.BedTool.random_jaccard">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">random_jaccard</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="n">BedTool</span><span class="p">,</span>
        <span class="n">genome_fn</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">iterations</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">processes</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">_orig_pool</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Pool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">shuffle_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">jaccard_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the naive Jaccard statistic (intersection divided by union).</span>

<span class="sd">        .. note::</span>

<span class="sd">            If you don&#39;t need the randomization functionality of this method,</span>
<span class="sd">            you can use the simpler BedTool.jaccard method instead.</span>

<span class="sd">        See Favorov et al. (2012) PLoS Comput Biol 8(5): e1002529 for more</span>
<span class="sd">        info on the Jaccard statistic for intersections.</span>

<span class="sd">        If `iterations` is None, then do not perform random shufflings.</span>

<span class="sd">        If `iterations` is an integer, perform `iterations` random shufflings,</span>
<span class="sd">        each time computing the Jaccard statistic to build an empirical</span>
<span class="sd">        distribution.  `genome_fn` will also be needed; optional `processes`</span>
<span class="sd">        will split the iterations across multiple CPUs.</span>

<span class="sd">        Returns a tuple of the observed Jaccard statistic and a list of the</span>
<span class="sd">        randomized statistics (which will be an empty list if `iterations` was</span>
<span class="sd">        None).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">shuffle_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shuffle_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">jaccard_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">jaccard_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">genome_fn</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Need a genome filename in order to perform randomization&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parallel_apply</span><span class="p">(</span>
                <span class="n">iterations</span><span class="o">=</span><span class="n">iterations</span> <span class="k">if</span> <span class="n">iterations</span> <span class="k">else</span> <span class="mi">1</span><span class="p">,</span>
                <span class="n">func</span><span class="o">=</span><span class="n">pybedtools</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">random_jaccard</span><span class="p">,</span>
                <span class="n">func_args</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">),</span>
                <span class="n">func_kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                    <span class="n">genome_fn</span><span class="o">=</span><span class="n">genome_fn</span><span class="p">,</span>
                    <span class="n">shuffle_kwargs</span><span class="o">=</span><span class="n">shuffle_kwargs</span><span class="p">,</span>
                    <span class="n">jaccard_kwargs</span><span class="o">=</span><span class="n">jaccard_kwargs</span><span class="p">,</span>
                <span class="p">),</span>
                <span class="n">processes</span><span class="o">=</span><span class="n">processes</span><span class="p">,</span>
                <span class="n">_orig_pool</span><span class="o">=</span><span class="n">_orig_pool</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_randomintersection</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="n">BedTool</span><span class="p">,</span>
        <span class="n">iterations</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">genome_fn</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">intersect_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">_orig_pool</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="n">Pool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">shuffle_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">processes</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Re-implementation of BedTool.randomintersection using the new</span>
<span class="sd">        `random_op` method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">shuffle_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shuffle_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">intersect_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">intersect_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">u</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">genome_fn</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Need a genome filename in order to perform randomization&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parallel_apply</span><span class="p">(</span>
                <span class="n">iterations</span><span class="o">=</span><span class="n">iterations</span><span class="p">,</span>
                <span class="n">func</span><span class="o">=</span><span class="n">pybedtools</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">random_intersection</span><span class="p">,</span>
                <span class="n">func_args</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">),</span>
                <span class="n">func_kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                    <span class="n">genome_fn</span><span class="o">=</span><span class="n">genome_fn</span><span class="p">,</span>
                    <span class="n">shuffle_kwargs</span><span class="o">=</span><span class="n">shuffle_kwargs</span><span class="p">,</span>
                    <span class="n">intersect_kwargs</span><span class="o">=</span><span class="n">intersect_kwargs</span><span class="p">,</span>
                <span class="p">),</span>
                <span class="n">processes</span><span class="o">=</span><span class="n">processes</span><span class="p">,</span>
                <span class="n">_orig_pool</span><span class="o">=</span><span class="n">_orig_pool</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

<div class="viewcode-block" id="BedTool.randomintersection_bp">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.randomintersection_bp.html#pybedtools.bedtool.BedTool.randomintersection_bp">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">randomintersection_bp</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="n">BedTool</span><span class="p">,</span>
        <span class="n">iterations</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">genome_fn</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">intersect_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">shuffle_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">processes</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">_orig_pool</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="n">Pool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Like randomintersection, but return the bp overlap instead of the</span>
<span class="sd">        number of intersecting intervals.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">shuffle_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shuffle_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">intersect_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">intersect_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">genome_fn</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Need a genome filename in order to perform randomization&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parallel_apply</span><span class="p">(</span>
                <span class="n">iterations</span><span class="o">=</span><span class="n">iterations</span><span class="p">,</span>
                <span class="n">func</span><span class="o">=</span><span class="n">pybedtools</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">random_intersection_bp</span><span class="p">,</span>
                <span class="n">func_args</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">),</span>
                <span class="n">func_kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                    <span class="n">genome_fn</span><span class="o">=</span><span class="n">genome_fn</span><span class="p">,</span>
                    <span class="n">shuffle_kwargs</span><span class="o">=</span><span class="n">shuffle_kwargs</span><span class="p">,</span>
                    <span class="n">intersect_kwargs</span><span class="o">=</span><span class="n">intersect_kwargs</span><span class="p">,</span>
                <span class="p">),</span>
                <span class="n">processes</span><span class="o">=</span><span class="n">processes</span><span class="p">,</span>
                <span class="n">_orig_pool</span><span class="o">=</span><span class="n">_orig_pool</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="BedTool.randomintersection">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.randomintersection.html#pybedtools.bedtool.BedTool.randomintersection">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">randomintersection</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="n">BedTool</span><span class="p">,</span>
        <span class="n">iterations</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">intersect_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">shuffle_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">debug</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">report_iterations</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">processes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">_orig_processes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform `iterations` shufflings, each time intersecting with `other`.</span>

<span class="sd">        Returns a generator of integers where each integer is the number of</span>
<span class="sd">        intersections of a shuffled file with *other*. This distribution can</span>
<span class="sd">        be used in downstream analysis for things like empirical p-values.</span>

<span class="sd">        *intersect_kwargs* and *shuffle_kwargs* are passed to self.intersect()</span>
<span class="sd">        and self.shuffle() respectively.  By default for intersect, u=True is</span>
<span class="sd">        specified -- but s=True might be a useful option for strand-specific</span>
<span class="sd">        work.</span>

<span class="sd">        Useful kwargs for *shuffle_kwargs* are chrom, excl, or incl.  If you</span>
<span class="sd">        use the &quot;seed&quot; kwarg, that seed will be used *each* time shuffleBed is</span>
<span class="sd">        called -- so all your randomization results will be identical for each</span>
<span class="sd">        iteration.  To get around this and to allow for tests, debug=True will</span>
<span class="sd">        set the seed to the iteration number.  You may also break up the</span>
<span class="sd">        intersections across multiple processes with *processes* &gt; 1.</span>

<span class="sd">        Example usage:</span>

<span class="sd">            &gt;&gt;&gt; chromsizes = {&#39;chr1&#39;:(0, 1000)}</span>
<span class="sd">            &gt;&gt;&gt; a = pybedtools.example_bedtool(&#39;a.bed&#39;)</span>
<span class="sd">            &gt;&gt;&gt; a = a.set_chromsizes(chromsizes)</span>
<span class="sd">            &gt;&gt;&gt; b = pybedtools.example_bedtool(&#39;b.bed&#39;)</span>
<span class="sd">            &gt;&gt;&gt; results = a.randomintersection(b, 10, debug=True)</span>
<span class="sd">            &gt;&gt;&gt; print(list(results))</span>
<span class="sd">            [1, 0, 1, 2, 4, 2, 2, 1, 2, 4]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">processes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="p">)</span>
            <span class="n">iterations_each</span> <span class="o">=</span> <span class="p">[</span><span class="n">iterations</span> <span class="o">//</span> <span class="n">processes</span><span class="p">]</span> <span class="o">*</span> <span class="n">processes</span>
            <span class="n">iterations_each</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">iterations</span> <span class="o">%</span> <span class="n">processes</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">p</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span>
                    <span class="n">_call_randomintersect</span><span class="p">,</span>
                    <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">it</span><span class="p">),</span>
                    <span class="nb">dict</span><span class="p">(</span>
                        <span class="n">intersect_kwargs</span><span class="o">=</span><span class="n">intersect_kwargs</span><span class="p">,</span>
                        <span class="n">shuffle_kwargs</span><span class="o">=</span><span class="n">shuffle_kwargs</span><span class="p">,</span>
                        <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">,</span>
                        <span class="n">report_iterations</span><span class="o">=</span><span class="n">report_iterations</span><span class="p">,</span>
                        <span class="n">_orig_processes</span><span class="o">=</span><span class="n">processes</span><span class="p">,</span>
                    <span class="p">),</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">iterations_each</span>
            <span class="p">]</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">get</span><span class="p">():</span>
                    <span class="k">yield</span> <span class="n">value</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span>

        <span class="k">if</span> <span class="n">shuffle_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shuffle_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">intersect_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">intersect_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;u&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>

        <span class="k">if</span> <span class="s2">&quot;u&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">intersect_kwargs</span><span class="p">:</span>
            <span class="n">intersect_kwargs</span><span class="p">[</span><span class="s2">&quot;u&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">resort</span> <span class="o">=</span> <span class="n">intersect_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sorted&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iterations</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="n">shuffle_kwargs</span><span class="p">[</span><span class="s2">&quot;seed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">if</span> <span class="n">report_iterations</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">_orig_processes</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\r</span><span class="s2">approx (total across </span><span class="si">%s</span><span class="s2"> processes): </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                        <span class="n">_orig_processes</span><span class="p">,</span>
                        <span class="n">i</span> <span class="o">*</span> <span class="n">_orig_processes</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\r</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">i</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

            <span class="c1"># Re-sort if sorted=True in kwargs</span>
            <span class="k">if</span> <span class="n">resort</span><span class="p">:</span>
                <span class="n">tmp0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="o">**</span><span class="n">shuffle_kwargs</span><span class="p">)</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp0</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="o">**</span><span class="n">shuffle_kwargs</span><span class="p">)</span>

            <span class="n">tmp2</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">intersect_kwargs</span><span class="p">)</span>

            <span class="k">yield</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmp2</span><span class="p">)</span>

            <span class="c1"># Close the open stdouts from subprocess.Popen calls.  Note: doing</span>
            <span class="c1"># this in self.__del__ doesn&#39;t fix the open file limit bug; it</span>
            <span class="c1"># needs to be done here.</span>
            <span class="c1"># if resort:</span>
            <span class="c1">#     tmp0.fn.close()</span>
            <span class="c1"># tmp.fn.close()</span>
            <span class="n">tmp2</span><span class="o">.</span><span class="n">fn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">del</span> <span class="n">tmp</span>
            <span class="k">del</span> <span class="n">tmp2</span></div>


<div class="viewcode-block" id="BedTool.cat">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.cat.html#pybedtools.bedtool.BedTool.cat">[docs]</a>
    <span class="nd">@_log_to_history</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">cat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">others</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="o">|</span><span class="n">Path</span><span class="o">|</span><span class="n">BedTool</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Concatenate interval files together.</span>

<span class="sd">        Concatenates two BedTool objects (or an object and a file) and does an</span>
<span class="sd">        optional post-merge of the features.</span>

<span class="sd">        *postmerge=True* by default; use *postmerge=False* if you want to keep</span>
<span class="sd">        features separate.</span>

<span class="sd">        *force_truncate=False* by default; *force_truncate=True* to truncate</span>
<span class="sd">        all files to chrom, start, stop.</span>

<span class="sd">        When *force_truncate=False* and *postmerge=False*, the output will</span>
<span class="sd">        contain the smallest number of fields observed across all inputs. This</span>
<span class="sd">        maintains compatibility with BEDTools programs, which assume constant</span>
<span class="sd">        number of fields in all lines of a file.</span>

<span class="sd">        Other kwargs are sent to :meth:`BedTool.merge` (and assuming that</span>
<span class="sd">        *postmerge=True*).</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; a = pybedtools.example_bedtool(&#39;a.bed&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b = pybedtools.example_bedtool(&#39;b.bed&#39;)</span>
<span class="sd">        &gt;&gt;&gt; print(a.cat(b)) #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        chr1	1	500</span>
<span class="sd">        chr1	800	950</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        &gt;&gt;&gt; print(a.cat(*[b,b],</span>
<span class="sd">        ...   postmerge=False)) #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        chr1	1	100	feature1	0	+</span>
<span class="sd">        chr1	100	200	feature2	0	+</span>
<span class="sd">        chr1	150	500	feature3	0	-</span>
<span class="sd">        chr1	900	950	feature4	0	+</span>
<span class="sd">        chr1	155	200	feature5	0	-</span>
<span class="sd">        chr1	800	901	feature6	0	+</span>
<span class="sd">        chr1	155	200	feature5	0	-</span>
<span class="sd">        chr1	800	901	feature6	0	+</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">same_type</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">same_field_num</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">field_nums</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">others</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;You must specify at least one other bedfile!&quot;</span>
        <span class="n">other_beds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">other</span> <span class="ow">in</span> <span class="n">others</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">)):</span>
                <span class="n">other</span> <span class="o">=</span> <span class="n">BedTool</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
                    <span class="n">other</span><span class="p">,</span> <span class="n">BedTool</span>
                <span class="p">),</span> <span class="s2">&quot;Either filename or another BedTool instance required&quot;</span>
            <span class="n">other_beds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="c1"># postmerge and force_truncate don&#39;t get passed on to merge</span>
        <span class="n">postmerge</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;postmerge&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">force_truncate</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;force_truncate&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">stream_merge</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;stream&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">stream_merge</span> <span class="ow">and</span> <span class="n">postmerge</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The post-merge step in the `cat()` method &quot;</span>
                <span class="s2">&quot;performs a sort, which uses stream=True.  Using &quot;</span>
                <span class="s2">&quot;stream=True for the merge as well will result in a &quot;</span>
                <span class="s2">&quot;deadlock!&quot;</span>
            <span class="p">)</span>

        <span class="c1"># if filetypes and field counts are the same, don&#39;t truncate</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">force_truncate</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">filetypes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
                    <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">file_type</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">file_type</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">other_beds</span><span class="p">]</span>
                <span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">([</span><span class="s2">&quot;empty&quot;</span><span class="p">])</span>
                <span class="n">field_nums</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="nb">set</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">field_count</span><span class="p">()]</span> <span class="o">+</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">field_count</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">other_beds</span><span class="p">])</span>
                    <span class="o">.</span><span class="n">difference</span><span class="p">([</span><span class="kc">None</span><span class="p">])</span>
                    <span class="o">.</span><span class="n">difference</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
                <span class="p">)</span>
                <span class="n">same_field_num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">field_nums</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="n">same_type</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">filetypes</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Can&#39;t check filetype or field count -- &quot;</span>
                    <span class="s2">&quot;is one of the files you&#39;re merging a &#39;streaming&#39; &quot;</span>
                    <span class="s2">&quot;BedTool?  If so, use .saveas() to save to file first&quot;</span>
                <span class="p">)</span>

        <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmp</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">force_truncate</span> <span class="ow">and</span> <span class="n">same_type</span> <span class="ow">and</span> <span class="n">same_field_num</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">TMP</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="n">TMP</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">other</span> <span class="ow">in</span> <span class="n">other_beds</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
                        <span class="n">TMP</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>

        <span class="c1"># Types match, so we can use the min number of fields observed across</span>
        <span class="c1"># all inputs</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">force_truncate</span> <span class="ow">and</span> <span class="n">same_type</span><span class="p">:</span>
            <span class="n">minfields</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">field_nums</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">TMP</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="n">TMP</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">fields</span><span class="p">[:</span><span class="n">minfields</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">other</span> <span class="ow">in</span> <span class="n">other_beds</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
                        <span class="n">TMP</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">fields</span><span class="p">[:</span><span class="n">minfields</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Otherwise, use the zero-based chrom/start/stop to create a BED3,</span>
        <span class="c1"># which will work when catting a GFF and a BED together.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">TMP</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="n">TMP</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="se">\t</span><span class="si">%i</span><span class="se">\t</span><span class="si">%i</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">end</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">other</span> <span class="ow">in</span> <span class="n">other_beds</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
                        <span class="n">TMP</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="se">\t</span><span class="si">%i</span><span class="se">\t</span><span class="si">%i</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">end</span><span class="p">))</span>

        <span class="n">c</span> <span class="o">=</span> <span class="n">BedTool</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">postmerge</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="c1"># Explicitly delete -- needed when using multiprocessing</span>
            <span class="n">os</span><span class="o">.</span><span class="n">unlink</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">d</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">c</span></div>


<div class="viewcode-block" id="BedTool.saveas">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.saveas.html#pybedtools.bedtool.BedTool.saveas">[docs]</a>
    <span class="nd">@_log_to_history</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">saveas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">trackline</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">compressed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a copy of the BedTool.</span>

<span class="sd">        Optionally adds `trackline` to the beginning of the file.</span>

<span class="sd">        Optionally compresses output using gzip.</span>

<span class="sd">        if the filename extension is .gz, or compressed=True,</span>
<span class="sd">        the output is compressed using gzip</span>

<span class="sd">        Returns a new BedTool for the newly saved file.</span>

<span class="sd">        A newline is automatically added to the trackline if it does not</span>
<span class="sd">        already have one.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; a = pybedtools.example_bedtool(&#39;a.bed&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b = a.saveas(&#39;other.bed&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b.fn</span>
<span class="sd">        &#39;other.bed&#39;</span>
<span class="sd">        &gt;&gt;&gt; print(b == a)</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; b = a.saveas(&#39;other.bed&#39;, trackline=&quot;name=&#39;test run&#39; color=0,55,0&quot;)</span>
<span class="sd">        &gt;&gt;&gt; open(b.fn).readline()</span>
<span class="sd">        &quot;name=&#39;test run&#39; color=0,55,0\\n&quot;</span>
<span class="sd">        &gt;&gt;&gt; if os.path.exists(&#39;other.bed&#39;):</span>
<span class="sd">        ...     os.unlink(&#39;other.bed&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmp</span><span class="p">()</span>

        <span class="c1"># Default to compressed if extension is .gz</span>
        <span class="k">if</span> <span class="n">compressed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">__</span><span class="p">,</span> <span class="n">extension</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">extension</span> <span class="o">==</span> <span class="s2">&quot;.gz&quot;</span><span class="p">:</span>
                <span class="n">compressed</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">compressed</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">in_compressed</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isGZIP</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">)</span>

        <span class="n">fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_collapse</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">fn</span><span class="o">=</span><span class="n">fn</span><span class="p">,</span>
            <span class="n">trackline</span><span class="o">=</span><span class="n">trackline</span><span class="p">,</span>
            <span class="n">in_compressed</span><span class="o">=</span><span class="n">in_compressed</span><span class="p">,</span>
            <span class="n">out_compressed</span><span class="o">=</span><span class="n">compressed</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">BedTool</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span></div>


<div class="viewcode-block" id="BedTool.moveto">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.moveto.html#pybedtools.bedtool.BedTool.moveto">[docs]</a>
    <span class="nd">@_log_to_history</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">moveto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Move to a new filename (can be much quicker than BedTool.saveas())</span>

<span class="sd">        Move BED file to new filename, `fn`.</span>

<span class="sd">        Returns a new BedTool for the new file.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; # make a copy so we don&#39;t mess up the example file</span>
<span class="sd">        &gt;&gt;&gt; a = pybedtools.example_bedtool(&#39;a.bed&#39;).saveas()</span>
<span class="sd">        &gt;&gt;&gt; a_contents = str(a)</span>
<span class="sd">        &gt;&gt;&gt; b = a.moveto(&#39;other.bed&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b.fn</span>
<span class="sd">        &#39;other.bed&#39;</span>
<span class="sd">        &gt;&gt;&gt; b == a_contents</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_collapse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="o">=</span><span class="n">fn</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">,</span> <span class="n">fn</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BedTool</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span></div>


<div class="viewcode-block" id="BedTool.random_subset">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.random_subset.html#pybedtools.bedtool.BedTool.random_subset">[docs]</a>
    <span class="nd">@_log_to_history</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">random_subset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="o">|</span><span class="nb">int</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a BedTool containing a random subset.</span>

<span class="sd">        NOTE: using `n` will be slower and use more memory than using `f`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        n : int</span>
<span class="sd">            Number of features to return. Only one of `n` or `f` can be provided.</span>

<span class="sd">        f : float, 0 &lt;= f &lt;= 1</span>
<span class="sd">            Fraction of features to return. Cannot be provided with `n`.</span>

<span class="sd">        seed : float or int</span>
<span class="sd">            Set random.seed</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>

<span class="sd">        &gt;&gt;&gt; seed = 0  # only for test, otherwise use None</span>

<span class="sd">        `n` will always give the same number of returned features, but will be</span>
<span class="sd">        slower since it is creating an index and then shuffling it.</span>

<span class="sd">        &gt;&gt;&gt; a = pybedtools.example_bedtool(&#39;a.bed&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b = a.random_subset(n=2)</span>
<span class="sd">        &gt;&gt;&gt; len(b)</span>
<span class="sd">        2</span>

<span class="sd">        Using a fraction `f` will be faster but depending on seed will result</span>
<span class="sd">        in slightly different total numbers.</span>

<span class="sd">        &gt;&gt;&gt; a = pybedtools.example_bedtool(&#39;x.bam&#39;)</span>
<span class="sd">        &gt;&gt;&gt; len(a)</span>
<span class="sd">        45593</span>
<span class="sd">        &gt;&gt;&gt; b = a.random_subset(f=0.4, seed=seed)</span>
<span class="sd">        &gt;&gt;&gt; len(b)</span>
<span class="sd">        18316</span>

<span class="sd">        Check that we have approximately the right fraction</span>
<span class="sd">        &gt;&gt;&gt; print(&#39;{0:.2f}&#39;.format(len(b) / len(a)))</span>
<span class="sd">        0.40</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">f</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">))</span> <span class="ow">or</span> <span class="p">((</span><span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Exactly one of `n` or `f` must be provided&quot;</span><span class="p">)</span>

        <span class="n">tmpfn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmp</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">n</span><span class="p">:</span>
            <span class="n">idxs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
            <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">idxs</span><span class="p">)</span>
            <span class="n">idxs</span> <span class="o">=</span> <span class="n">idxs</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">tmpfn</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">tmp</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">feature</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idxs</span><span class="p">:</span>
                        <span class="n">tmp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">feature</span><span class="p">))</span>

        <span class="k">elif</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">tmpfn</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">tmp</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">f</span><span class="p">:</span>
                        <span class="n">tmp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">BedTool</span><span class="p">(</span><span class="n">tmpfn</span><span class="p">)</span></div>


<div class="viewcode-block" id="BedTool.total_coverage">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.total_coverage.html#pybedtools.bedtool.BedTool.total_coverage">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">total_coverage</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the total number of bases covered by this interval file.</span>

<span class="sd">        Does a self.merge() first to remove potentially multiple-counting</span>
<span class="sd">        bases.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; a = pybedtools.example_bedtool(&#39;a.bed&#39;)</span>

<span class="sd">        This does a merge() first, so this is what the total coverage is</span>
<span class="sd">        counting:</span>

<span class="sd">        &gt;&gt;&gt; print(a.merge()) #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        chr1	1	500</span>
<span class="sd">        chr1	900	950</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>

<span class="sd">        &gt;&gt;&gt; print(a.total_coverage())</span>
<span class="sd">        549</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge</span><span class="p">()</span>
        <span class="n">total_bp</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">b</span><span class="o">.</span><span class="n">features</span><span class="p">():</span>
            <span class="n">total_bp</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">feature</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">total_bp</span></div>


<div class="viewcode-block" id="BedTool.with_attrs">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.with_attrs.html#pybedtools.bedtool.BedTool.with_attrs">[docs]</a>
    <span class="nd">@_log_to_history</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">with_attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper method for adding attributes in the middle of a pipeline.</span>

<span class="sd">        Given arbitrary keyword arguments, turns the keys and values into</span>
<span class="sd">        attributes.  Useful for labeling BedTools at creation time.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; # add a &quot;label&quot; attribute to each BedTool</span>
<span class="sd">        &gt;&gt;&gt; a = pybedtools.example_bedtool(&#39;a.bed&#39;)\</span>
<span class="sd">                                   .with_attrs(label=&#39;transcription factor 1&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b = pybedtools.example_bedtool(&#39;b.bed&#39;)\</span>
<span class="sd">                                   .with_attrs(label=&#39;transcription factor 2&#39;)</span>
<span class="sd">        &gt;&gt;&gt; for i in [a, b]:</span>
<span class="sd">        ...     print(&#39;{0} features for {1}&#39;.format(i.count(), i.label))</span>
<span class="sd">        4 features for transcription factor 1</span>
<span class="sd">        2 features for transcription factor 2</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="BedTool.as_intervalfile">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.as_intervalfile.html#pybedtools.bedtool.BedTool.as_intervalfile">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">as_intervalfile</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IntervalFile</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an IntervalFile of this BedTool for low-level interface.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_collapse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fn</span>
        <span class="k">return</span> <span class="n">IntervalFile</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span></div>


<div class="viewcode-block" id="BedTool.liftover">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.liftover.html#pybedtools.bedtool.BedTool.liftover">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">liftover</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chainfile</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">unmapped</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">liftover_args</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new BedTool of the liftedOver features, saving the unmapped</span>
<span class="sd">        ones as `unmapped`.  If `unmapped` is None, then discards the unmapped</span>
<span class="sd">        features.</span>

<span class="sd">        `liftover_args` is a string of additional args that is passed,</span>
<span class="sd">        verbatim, to liftOver.</span>

<span class="sd">        Needs `liftOver` from UCSC to be on the path and a `chainfile`</span>
<span class="sd">        downloaded from UCSC.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">BedTool</span><span class="o">.</span><span class="n">_tmp</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">unmapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">unmapped</span> <span class="o">=</span> <span class="n">BedTool</span><span class="o">.</span><span class="n">_tmp</span><span class="p">()</span>
        <span class="n">cmds</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;liftOver&quot;</span><span class="p">,</span> <span class="n">liftover_args</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">,</span> <span class="n">chainfile</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">unmapped</span><span class="p">]</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cmds</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">BedTool</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>


<div class="viewcode-block" id="BedTool.absolute_distance">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.absolute_distance.html#pybedtools.bedtool.BedTool.absolute_distance">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">absolute_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">BedTool</span><span class="p">,</span> <span class="n">closest_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_midpoints</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator of the *absolute* distances between features in</span>
<span class="sd">        self and other.</span>

<span class="sd">        If `use_midpoints` is True, then only use the midpoints of features</span>
<span class="sd">        (which will return values where features are overlapping).  Otherwise,</span>
<span class="sd">        when features overlap the value will always be zero.</span>

<span class="sd">        `closest_kwargs` are passed to self.closest(); either `d` or</span>
<span class="sd">        &#39;D` are required in order to get back distance values (`d=True` is</span>
<span class="sd">        default)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">.featurefuncs</span><span class="w"> </span><span class="kn">import</span> <span class="n">midpoint</span>

        <span class="k">if</span> <span class="n">closest_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">closest_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;d&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>

        <span class="k">if</span> <span class="s2">&quot;D&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">closest_kwargs</span><span class="p">:</span>
            <span class="n">closest_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">d</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">use_midpoints</span><span class="p">:</span>
            <span class="n">mid_self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">each</span><span class="p">(</span><span class="n">midpoint</span><span class="p">)</span><span class="o">.</span><span class="n">saveas</span><span class="p">()</span>
            <span class="n">mid_other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">each</span><span class="p">(</span><span class="n">midpoint</span><span class="p">)</span><span class="o">.</span><span class="n">saveas</span><span class="p">()</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">mid_self</span><span class="o">.</span><span class="n">closest</span><span class="p">(</span><span class="n">mid_other</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">closest_kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">closest</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">closest_kwargs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>
            <span class="k">yield</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span></div>


<div class="viewcode-block" id="BedTool.relative_distance">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.relative_distance.html#pybedtools.bedtool.BedTool.relative_distance">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">relative_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">BedTool</span><span class="p">,</span> <span class="n">genome</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="o">|</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">g</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator of relative distances between features in self and</span>
<span class="sd">        other.</span>

<span class="sd">        First computes the midpoints of self and other, then returns distances</span>
<span class="sd">        of each feature in `other` relative to the distance between `self`</span>
<span class="sd">        features.</span>

<span class="sd">        Requires either `genome` (dictionary of chromsizes or assembly name) or</span>
<span class="sd">        `g` (filename of chromsizes file).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">g_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">genome</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">g</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Need either `genome` or `g` arg for relative distance&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">genome</span> <span class="ow">and</span> <span class="n">g</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Please specify only one of `genome` or `g`&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">genome</span><span class="p">:</span>
            <span class="n">g_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">genome</span><span class="o">=</span><span class="n">genome</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">g</span><span class="p">:</span>
            <span class="n">g_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">g</span><span class="o">=</span><span class="n">g</span><span class="p">)</span>

        <span class="kn">from</span><span class="w"> </span><span class="nn">.featurefuncs</span><span class="w"> </span><span class="kn">import</span> <span class="n">midpoint</span>

        <span class="c1"># This gets the space between features in self.</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">each</span><span class="p">(</span><span class="n">midpoint</span><span class="p">)</span><span class="o">.</span><span class="n">complement</span><span class="p">(</span><span class="o">**</span><span class="n">g_dict</span><span class="p">)</span>

        <span class="n">hits</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">wao</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># TODO: should this be other or mid_other?</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">hits</span><span class="p">:</span>
            <span class="k">yield</span> <span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span></div>


<div class="viewcode-block" id="BedTool.colormap_normalize">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.colormap_normalize.html#pybedtools.bedtool.BedTool.colormap_normalize">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">colormap_normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                            <span class="n">vmin</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="o">|</span><span class="nb">int</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">vmax</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="o">|</span><span class="nb">int</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">percentile</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">log</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">LogNorm</span><span class="o">|</span><span class="n">mcolors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a normalization instance for use by featurefuncs.add_color().</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vmin, vmax : float, int, or None</span>
<span class="sd">            `vmin` and `vmax` set the colormap bounds; if None then</span>
<span class="sd">            these will be determined from the scores in the BED file.</span>

<span class="sd">        log : bool</span>
<span class="sd">            If True, put the scores on a log scale; of course be careful</span>
<span class="sd">            if you have negative scores</span>

<span class="sd">        percentile : bool</span>
<span class="sd">            If True, interpret vmin and vmax as a percentile in the range</span>
<span class="sd">            [0,100] rather than absolute values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">field_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">field_count</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_type</span> <span class="o">!=</span> <span class="s2">&quot;bed&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">field_count</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;colorizing only works for BED files with score &quot;</span> <span class="s2">&quot;fields&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.colors</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">mcolors</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;matplotlib.colors must be installed to use colormap_normalize&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;numpy must be installed to use colormap_normalize&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">LogNorm</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">()</span>

        <span class="n">scores</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span><span class="o">.</span><span class="n">score</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="n">scores</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">scores</span><span class="p">)]</span>
        <span class="n">norm</span><span class="o">.</span><span class="n">autoscale</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">vmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">percentile</span><span class="p">:</span>
                <span class="n">vmin</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">scores</span><span class="p">,</span> <span class="n">vmin</span><span class="p">))</span>
            <span class="n">norm</span><span class="o">.</span><span class="n">vmin</span> <span class="o">=</span> <span class="n">vmin</span>
        <span class="k">if</span> <span class="n">vmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">percentile</span><span class="p">:</span>
                <span class="n">vmax</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">scores</span><span class="p">,</span> <span class="n">vmax</span><span class="p">))</span>
            <span class="n">norm</span><span class="o">.</span><span class="n">vmax</span> <span class="o">=</span> <span class="n">vmax</span>

        <span class="k">return</span> <span class="n">norm</span></div>


<div class="viewcode-block" id="BedTool.at">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.BedTool.at.html#pybedtools.bedtool.BedTool.at">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inds</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">BedTool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new BedTool with only intervals at lines `inds`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inds : List[int]</span>
<span class="sd">            List of line numbers</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BedTool</span>
<span class="sd">            New BedTool with only intervals at `inds`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">inds</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_gen</span><span class="p">():</span>
            <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">feature</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">inds</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                    <span class="k">yield</span> <span class="n">feature</span>
                    <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">length</span><span class="p">:</span>
                        <span class="k">break</span>

        <span class="k">return</span> <span class="n">BedTool</span><span class="p">(</span><span class="n">_gen</span><span class="p">())</span><span class="o">.</span><span class="n">saveas</span><span class="p">()</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">to_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">disable_auto_names</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a pandas.DataFrame, passing args and kwargs to pandas.read_csv</span>
<span class="sd">        The separator kwarg `sep` is given a tab `\\t` as value by default.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        disable_auto_names : bool</span>
<span class="sd">            By default, the created dataframe fills in column names</span>
<span class="sd">            automatically according to the detected filetype (e.g., &quot;chrom&quot;,</span>
<span class="sd">            &quot;start&quot;, &quot;end&quot; for a BED3 file). Set this argument to True to</span>
<span class="sd">            disable this behavior.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Complain if BAM or if not a file</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isbam</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;BAM not supported for converting to DataFrame&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;use .saveas() to make sure self.fn is a file&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;pandas must be installed to convert to pandas.DataFrame&quot;</span><span class="p">)</span>
        <span class="c1"># Otherwise we&#39;re good:</span>
        <span class="n">names</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;names&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">disable_auto_names</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">_names</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">_column_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">file_type</span><span class="p">][:</span> <span class="bp">self</span><span class="o">.</span><span class="n">field_count</span><span class="p">()]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_names</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">field_count</span><span class="p">():</span>
                    <span class="n">warn</span><span class="p">(</span>
                        <span class="s2">&quot;Default names for filetype </span><span class="si">%s</span><span class="s2"> are:</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="s2">but file has &quot;</span>
                        <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> fields; you can supply custom names with the &quot;</span>
                        <span class="s2">&quot;`names` kwarg&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_type</span><span class="p">,</span> <span class="n">_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">field_count</span><span class="p">())</span>
                    <span class="p">)</span>
                    <span class="n">_names</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">_names</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;names&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_names</span>

        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">)</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getsize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pandas</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="c1"># type: ignore</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">tail</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lines</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">as_string</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Like `head`, but prints last 10 lines of the file by default.</span>

<span class="sd">        To avoid consuming iterables, this only works with file-based, non-BAM</span>
<span class="sd">        BedTool objects.</span>

<span class="sd">        Use `as_string=True` to return a string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isbam</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;tail() not yet implemented for BAM files&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;tail() not implemented for non-file-based &quot;</span>
                <span class="s2">&quot;BedTool objects.  Please use saveas() first.&quot;</span>
            <span class="p">)</span>
        <span class="n">bufsize</span> <span class="o">=</span> <span class="mi">8192</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">bufsize</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span>

        <span class="c1"># whence=2 arg means relative to end (i.e., go to the end)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">file_size</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">file_size</span> <span class="o">&lt;</span> <span class="n">bufsize</span><span class="p">:</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="n">file_size</span>
            <span class="n">f</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="o">-</span><span class="n">offset</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">chunk</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
            <span class="n">data</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">chunk</span><span class="o">.</span><span class="n">splitlines</span><span class="p">(</span><span class="kc">True</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">lines</span> <span class="ow">or</span> <span class="n">offset</span> <span class="o">==</span> <span class="n">file_size</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">offset</span> <span class="o">+=</span> <span class="n">bufsize</span>

        <span class="n">result</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">i</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="n">lines</span><span class="p">:]])</span>
        <span class="k">if</span> <span class="n">as_string</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>



<span class="k">class</span><span class="w"> </span><span class="nc">BAM</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps pysam.Samfile so that it yields pybedtools.Interval objects when</span>
<span class="sd">        iterated over.</span>

<span class="sd">        The pysam.Samfile can be accessed via the .pysam_bamfile attribute.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stream</span> <span class="o">=</span> <span class="n">stream</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only files are supported, not streams&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pysam_bamfile</span> <span class="o">=</span> <span class="n">pysam</span><span class="o">.</span><span class="n">Samfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_aligned_segment_to_interval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">rname</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">rname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pysam_bamfile</span><span class="o">.</span><span class="n">get_reference_name</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">rname</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rname</span> <span class="o">=</span> <span class="s2">&quot;*&quot;</span>

        <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">rnext</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">rnext</span> <span class="o">==</span> <span class="n">r</span><span class="o">.</span><span class="n">rname</span><span class="p">:</span>
                <span class="n">rnext</span> <span class="o">=</span> <span class="s2">&quot;=&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rnext</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pysam_bamfile</span><span class="o">.</span><span class="n">get_reference_name</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">rnext</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rnext</span> <span class="o">=</span> <span class="s2">&quot;*&quot;</span>

        <span class="c1"># SAM spec says if unavailable should be set to 0. Pysam sets to -1.</span>

        <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">pnext</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">pnext</span> <span class="o">=</span> <span class="s2">&quot;0&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># +1 here because cbedtools.pyx expects SAM -- which is 1-based --</span>
            <span class="c1"># but pysam uses 0-based.</span>
            <span class="n">pnext</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">pnext</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">cigarstring</span><span class="p">:</span>
            <span class="n">cigarstring</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">cigarstring</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cigarstring</span> <span class="o">=</span> <span class="s2">&quot;*&quot;</span>

        <span class="c1"># Rudimentary support.</span>
        <span class="c1"># TODO: remove when refactoring to new BAM iterating</span>
        <span class="n">tags</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">tags</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">t</span> <span class="o">=</span> <span class="s2">&quot;i&quot;</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                <span class="n">t</span> <span class="o">=</span> <span class="s2">&quot;f&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="s2">&quot;Z&quot;</span>
            <span class="n">tags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">:</span><span class="si">{1}</span><span class="s2">:</span><span class="si">{2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>

        <span class="n">tags</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">seq</span><span class="p">:</span>
            <span class="n">seq</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">seq</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">seq</span> <span class="o">=</span> <span class="s2">&quot;*&quot;</span>

        <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">qual</span><span class="p">:</span>
            <span class="n">qual</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">qual</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">qual</span> <span class="o">=</span> <span class="s2">&quot;*&quot;</span>

        <span class="n">fields</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">r</span><span class="o">.</span><span class="n">qname</span><span class="p">,</span>
            <span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">flag</span><span class="p">),</span>
            <span class="n">rname</span><span class="p">,</span>
            <span class="c1"># +1 here because cbedtools.pyx expects SAM -- which is 1-based --</span>
            <span class="c1"># but pysam uses 0-based.</span>
            <span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
            <span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">mapq</span><span class="p">),</span>
            <span class="n">cigarstring</span><span class="p">,</span>
            <span class="n">rnext</span><span class="p">,</span>
            <span class="n">pnext</span><span class="p">,</span>
            <span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">tlen</span><span class="p">),</span>
            <span class="n">seq</span><span class="p">,</span>
            <span class="n">qual</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="n">tags</span><span class="p">:</span>
            <span class="n">fields</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span>

        <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Found &#39;None&#39; in fields: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">fields</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">create_interval_from_list</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="c1"># TODO: this is PAINFUL but it ensures that existing tests work.  Once all</span>
    <span class="c1"># tests work, the new behavior will be to yield pysam AlignedSegment</span>
    <span class="c1"># objects directly.</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aligned_segment_to_interval</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pysam_bamfile</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__next__</span><span class="p">()</span>


<span class="k">class</span><span class="w"> </span><span class="nc">History</span><span class="p">(</span><span class="nb">list</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Represents one or many HistorySteps.  Mostly used for nicely formatting</span>
<span class="sd">        a series of HistorySteps.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">list</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">HistoryStep</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">bedtool_instance</span><span class="p">,</span> <span class="n">parent_tag</span><span class="p">,</span> <span class="n">result_tag</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Class to represent one step in the history.</span>

<span class="sd">        Mostly used for its __repr__ method, to try and exactly replicate code</span>
<span class="sd">        that can be pasted to re-do history steps</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">_name</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="vm">__name__</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fn</span> <span class="o">=</span> <span class="n">bedtool_instance</span><span class="o">.</span><span class="n">fn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent_tag</span> <span class="o">=</span> <span class="n">parent_tag</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result_tag</span> <span class="o">=</span> <span class="n">result_tag</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_clean_arg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">:</span> <span class="nb">str</span><span class="o">|</span><span class="n">BedTool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrap strings in quotes and convert bedtool instances to filenames.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">BedTool</span><span class="p">):</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">fn</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="s1">&#39;&quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">arg</span>
        <span class="k">return</span> <span class="n">arg</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Still not sure whether to use pybedtools.bedtool() or bedtool()</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;&lt;HistoryStep&gt; &quot;</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;BedTool(&quot;</span><span class="si">%(fn)s</span><span class="s1">&quot;).</span><span class="si">%(method)s</span><span class="s1">(</span><span class="si">%%</span><span class="s1">s</span><span class="si">%%</span><span class="s1">s)&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;BedTool(&quot;MISSING FILE: </span><span class="si">%(fn)s</span><span class="s1">&quot;)&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;.</span><span class="si">%(method)s</span><span class="s2">(</span><span class="si">%%</span><span class="s2">s</span><span class="si">%%</span><span class="s2">s)&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span>

        <span class="c1"># Format args and kwargs</span>
        <span class="n">args_string</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_clean_arg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">))</span>
        <span class="n">kwargs_string</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="p">[</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clean_arg</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">())]</span>
        <span class="p">)</span>
        <span class="c1"># stick a comma on the end if there&#39;s something here</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args_string</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">args_string</span> <span class="o">+=</span> <span class="s2">&quot;, &quot;</span>

        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">%</span> <span class="p">(</span><span class="n">args_string</span><span class="p">,</span> <span class="n">kwargs_string</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, parent tag: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_tag</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, result tag: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">result_tag</span>
        <span class="k">return</span> <span class="n">s</span>


<div class="viewcode-block" id="example_bedtool">
<a class="viewcode-back" href="../../autodocs/pybedtools.bedtool.example_bedtool.html#pybedtools.bedtool.example_bedtool">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">example_bedtool</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a bedtool using a bed file from the pybedtools examples directory.</span>
<span class="sd">    Use :func:`list_example_files` to see a list of files that are included.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">filenames</span><span class="o">.</span><span class="n">data_dir</span><span class="p">(),</span> <span class="n">fn</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> does not exist&quot;</span> <span class="o">%</span> <span class="n">fn</span>
        <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BedTool</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span></div>



<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">doctest</span>

    <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">(</span><span class="n">optionflags</span><span class="o">=</span><span class="n">doctest</span><span class="o">.</span><span class="n">ELLIPSIS</span> <span class="o">|</span> <span class="n">doctest</span><span class="o">.</span><span class="n">NORMALIZE_WHITESPACE</span><span class="p">)</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">pybedtools</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../main.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../main.html#running-tests-compiling-docs">Running tests, compiling docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../3-brief-examples.html">Three brief examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial-contents.html">Tutorial Contents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../topical-documentation-contents.html">Topical Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../FAQs.html">FAQs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scripts.html">Scripts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../autodoc_source.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pybedtools</span></code> Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changes.html">Changelog</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  <li><a href="../pybedtools.html">pybedtools</a><ul>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>

    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">pybedtools 0.11.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../pybedtools.html" accesskey="U">pybedtools</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">pybedtools.bedtool</a></li> 
      </ul>
    </div>


    <div class="footer">
      &#169;2010-2015, Ryan Dale.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.1.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
    </div>

    

    
  </body>
</html>