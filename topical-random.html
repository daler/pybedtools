
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Randomization &#8212; pybedtools 0.9.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Wrapping new tools" href="topical-wrapping.html" />
    <link rel="prev" title="Specifying genomes" href="topical-genome.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="randomization">
<h1>Randomization<a class="headerlink" href="#randomization" title="Permalink to this heading">¶</a></h1>
<p><code class="xref py py-mod docutils literal notranslate"><span class="pre">pybedtools</span></code> provides some basic functionality for assigning some
significance value to the overlap between two BEDfiles.</p>
<p>The strategy is to randomly shuffle a file many times, each time doing an
intersection with another file of interest and counting the number of
intersections (or computing some other statistic on the overlap).  Upon doing
this many times, an empirical distribution is constructed, and the number of
intersections between the original, un-shuffled file is compared to this
empirical distribution to obtain a p-value, or compared to the median of the
distribution to get a score.</p>
<p>There are two methods, <code class="xref py py-meth docutils literal notranslate"><span class="pre">pybedtools.BedTool.randomintersection()</span></code> which does the
brute force randomizations, and <code class="xref py py-meth docutils literal notranslate"><span class="pre">BedTool.randomstats()</span></code> which compiles
and reports the results from the former method.</p>
<section id="example-workflow">
<h2>Example workflow<a class="headerlink" href="#example-workflow" title="Permalink to this heading">¶</a></h2>
<p>As a somewhat trivial example, we’ll intersect the example <code class="file docutils literal notranslate"><span class="pre">a.bed</span></code> with
<code class="file docutils literal notranslate"><span class="pre">b.bed</span></code>, taking care to set some options that will let it run in a
determinisitic way so that these tests will run.</p>
<p>We will be shuffling <code class="file docutils literal notranslate"><span class="pre">a.bed</span></code>, so we’ll need to specify the limits of its
chromosomes with <code class="xref py py-meth docutils literal notranslate"><span class="pre">BedTool.set_chromsizes()</span></code>.  Here, we set it to an
artifically small chromosome size so that we can get some meaningful
results in reasonable time.  In practice, you would either supply your own
dictionary or use a string assembly name (e.g., <code class="file docutils literal notranslate"><span class="pre">'hg19'</span></code>, <code class="file docutils literal notranslate"><span class="pre">'mm9'</span></code>, <code class="file docutils literal notranslate"><span class="pre">'dm3'</span></code>,
etc).  The genome-handling code will find the chromsizes we’ve set, so
there’s no need to tell <code class="file docutils literal notranslate"><span class="pre">shuffleBed</span></code> which genome file to use each time.</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">chromsizes</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;chr1&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">pybedtools</span><span class="o">.</span><span class="n">example_bedtool</span><span class="p">(</span><span class="s1">&#39;a.bed&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">set_chromsizes</span><span class="p">(</span><span class="n">chromsizes</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">pybedtools</span><span class="o">.</span><span class="n">example_bedtool</span><span class="p">(</span><span class="s1">&#39;b.bed&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>We have the option of specifying what kwargs to provide
<code class="xref py py-meth docutils literal notranslate"><span class="pre">BedTool.shuffle()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">BedTool.intersect()</span></code>, which will be called
each iteration.  In this example, we’ll tell <code class="file docutils literal notranslate"><span class="pre">shuffleBed</span></code> to only shuffle
within the chromsome just to illustrate the kwargs passing. We also need to
specify how many iterations to perform.  In practice, 1000 or 10000 are
good numbers, but for the sake of this example we’ll only do 100.</p>
<p>Last, setting <code class="file docutils literal notranslate"><span class="pre">debug=True</span></code> means that the random seed will be set in a
predictable manner so that we’ll always get the same results for testing.
In practice, make sure you use <code class="file docutils literal notranslate"><span class="pre">debug=False</span></code> (the default) to ensure random
results.</p>
<p>Furthermore, using the <code class="file docutils literal notranslate"><span class="pre">processes</span></code> kwarg will substantially speed up the
comparison (e.g., <code class="file docutils literal notranslate"><span class="pre">processes=8</span></code> to split the randomizations across 8 cores).</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">randomintersection</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">shuffle_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;chrom&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span> <span class="n">debug</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="file docutils literal notranslate"><span class="pre">results</span></code> is a generator of intersection counts where each number is the
number of times the shuffled <code class="file docutils literal notranslate"><span class="pre">a</span></code> intersected with <code class="file docutils literal notranslate"><span class="pre">b</span></code>.  We need to convert
it to a list in order to look at it:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
<span class="go">100</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">results</span><span class="p">[:</span><span class="mi">10</span><span class="p">])</span>
<span class="go">[1, 0, 1, 2, 4, 2, 2, 1, 2, 4]</span>
</pre></div>
</div>
<p>Running thousands of iterations on files with many features will of course
result in more complex results.  We could then take these results and plot
them in matplotlib, or get some statistics on them.</p>
<p>The method <code class="xref py py-meth docutils literal notranslate"><span class="pre">BedTool.randomstats()</span></code> does this for us, but requires NumPy
and SciPy to be installed.  This method also calls
<code class="xref py py-meth docutils literal notranslate"><span class="pre">BedTool.randomintersection()</span></code> for us, returning the summarized results
in a dictionary.</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">BedTool.randomstats()</span></code> takes the same arguments as
<code class="xref py py-meth docutils literal notranslate"><span class="pre">BedTool.randomintersection()</span></code>:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">results_dict</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">randomstats</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">shuffle_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;chrom&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span> <span class="n">debug</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>The keys to this results dictionary are as follows (some are redundant,
I’ve found these keys useful for writing out to file):</p>
<dl class="field-list simple">
<dt class="field-odd">iterations<span class="colon">:</span></dt>
<dd class="field-odd"><p>the number of iterations we specified</p>
</dd>
<dt class="field-even">actual<span class="colon">:</span></dt>
<dd class="field-even"><p>the number of intersections between then un-shuffled <code class="file docutils literal notranslate"><span class="pre">a</span></code> and <code class="file docutils literal notranslate"><span class="pre">b</span></code></p>
</dd>
<dt class="field-odd">file_a<span class="colon">:</span></dt>
<dd class="field-odd"><p>the filename of <code class="file docutils literal notranslate"><span class="pre">a</span></code></p>
</dd>
<dt class="field-even">file_b<span class="colon">:</span></dt>
<dd class="field-even"><p>the filename of <code class="file docutils literal notranslate"><span class="pre">b</span></code></p>
</dd>
<dt class="field-odd">&lt;file_a&gt;<span class="colon">:</span></dt>
<dd class="field-odd"><p>the key is actully the filename of <code class="file docutils literal notranslate"><span class="pre">a</span></code>, and the value is the number of
features in <code class="file docutils literal notranslate"><span class="pre">a</span></code></p>
</dd>
<dt class="field-even">&lt;file_b&gt;<span class="colon">:</span></dt>
<dd class="field-even"><p>the key is actually the filename of <code class="file docutils literal notranslate"><span class="pre">b</span></code> and the value is the number of
features in <code class="file docutils literal notranslate"><span class="pre">b</span></code></p>
</dd>
<dt class="field-odd">self<span class="colon">:</span></dt>
<dd class="field-odd"><p>number of features in <code class="file docutils literal notranslate"><span class="pre">a</span></code> (or “self”; same value as for &lt;file_a&gt;)</p>
</dd>
<dt class="field-even">other<span class="colon">:</span></dt>
<dd class="field-even"><p>number of features in <code class="file docutils literal notranslate"><span class="pre">b</span></code> (or “other”; same value as for &lt;file_b&gt;)</p>
</dd>
<dt class="field-odd">frac randomized above actual<span class="colon">:</span></dt>
<dd class="field-odd"><p>fraction of iterations that had counts above the actual count</p>
</dd>
<dt class="field-even">frac randomized below actual<span class="colon">:</span></dt>
<dd class="field-even"><p>fraction of iterations that had counts below the actual count</p>
</dd>
<dt class="field-odd">median randomized<span class="colon">:</span></dt>
<dd class="field-odd"><p>the median of the distribution of randomized intersections</p>
</dd>
<dt class="field-even">normalized<span class="colon">:</span></dt>
<dd class="field-even"><p>the actual count divided by the median; can be considered as a score</p>
</dd>
<dt class="field-odd">percentile<span class="colon">:</span></dt>
<dd class="field-odd"><p>the percentile of actual within the distribution of randomized
intersections; can be considered an empirical p-value</p>
</dd>
<dt class="field-even">upper 97.5th<span class="colon">:</span></dt>
<dd class="field-even"><p>the 97.5th percentile of the randomized distribution</p>
</dd>
<dt class="field-odd">lower 2.5th<span class="colon">:</span></dt>
<dd class="field-odd"><p>the 2.5th percentile of the randomized distribution</p>
</dd>
</dl>
<p>For example:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="s1">&#39;other&#39;</span><span class="p">,</span> <span class="s1">&#39;actual&#39;</span><span class="p">,</span> <span class="s1">&#39;median randomized&#39;</span><span class="p">,</span> <span class="s1">&#39;normalized&#39;</span><span class="p">,</span> <span class="s1">&#39;percentile&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">results_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>
<span class="go">self: 4</span>
<span class="go">other: 2</span>
<span class="go">actual: 3</span>
<span class="go">median randomized: 2.0</span>
<span class="go">normalized: 1.5</span>
<span class="go">percentile: 90.0</span>
</pre></div>
</div>
<p>Contributions toward improving this code or implementing other methods of
statistical testing are very welcome!</p>
</section>
<section id="other-statistics">
<h2>Other statistics<a class="headerlink" href="#other-statistics" title="Permalink to this heading">¶</a></h2>
<p>In practice, a comparison between two sets of features (say, two transcription
factors) with 1000 randomizations will have an empirical p-value of &lt; 0.001.
That is, out of all the randomizations performed,  every single one had fewer
intersections than the original.  Of course the resolution of the p-value is
dependent on the number of randomizations:  the lowest nonzero p-value for
10000 iterations will be 0.0001.  Getting a non-zero p-value often requires
doing more randomizations than is practical (several million to tens of
millions).</p>
<p>That’s where the enrichment score comes in.  The randomized intersections
typically have a normal distribution, but just in case, we take the median of
the randomized intersections and call this the background or control.  Then we
divide the actual intersections by this median to get an enrichment score.</p>
<p>The advantage to using the enrichment score is that it gives nonzero scores for
more fine-grained comparison among sets of features without performing
impractical amounts of randomization.  The first example of its usage that I’m
aware of is Negre et al. (2010) PLoS Genet 6(1): e1000814,  The downside of
this metric is that the numbers are relative, and have their greatest utility
for making biological conclusions when used in large matrices of pairwise
comparisons.</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">BedTool.randomintersection()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">BedTool.randomstats()</span></code> both use the
intersection count method.  That is, for each randomization the calculated
metric is “number of intersection events”.  An alternative is to compute the
Jaccard statistic on each iteration, as implemented in
<code class="xref py py-meth docutils literal notranslate"><span class="pre">BedTool.naive_jaccard()</span></code>. The Jaccard statistic (or Jaccard similarity) is
the ratio of the intersection over the union, and is introduced in a genomic
intersection context in Favorov et al. (2012) PLoS Comput Biol 8(5): e1002529.
However, this still has the same p-value resolution limitation, so the
actual-divided-by-median approach could be tried here as well.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">pybedtools</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="main.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="main.html#running-tests-compiling-docs">Running tests, compiling docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="3-brief-examples.html">Three brief examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial-contents.html">Tutorial Contents</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="topical-documentation-contents.html">Topical Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="topical-design-principles.html">Design principles</a></li>
<li class="toctree-l2"><a class="reference internal" href="topical-create-a-bedtool.html">Creating a <code class="xref py py-class docutils literal notranslate"><span class="pre">BedTool</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="topical-saving.html">Saving <code class="xref py py-class docutils literal notranslate"><span class="pre">BedTool</span></code> results</a></li>
<li class="toctree-l2"><a class="reference internal" href="topical-iterators.html">Using BedTool objects as iterators/generators</a></li>
<li class="toctree-l2"><a class="reference internal" href="topical-low-level-ops.html">Low-level operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="topical-bam.html">Working with BAM files</a></li>
<li class="toctree-l2"><a class="reference internal" href="topical-bam-semantics.html">Notes on BAM file semantics</a></li>
<li class="toctree-l2"><a class="reference internal" href="topical-genome.html">Specifying genomes</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Randomization</a></li>
<li class="toctree-l2"><a class="reference internal" href="topical-wrapping.html">Wrapping new tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="topical-comparisons.html">Comparisons</a></li>
<li class="toctree-l2"><a class="reference internal" href="sh-comparison.html">Shell script comparison</a></li>
<li class="toctree-l2"><a class="reference internal" href="pybedtools-dev-history.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pybedtools</span></code> development model</a></li>
<li class="toctree-l2"><a class="reference internal" href="flow-of-commands.html">Under the hood</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="FAQs.html">FAQs</a></li>
<li class="toctree-l1"><a class="reference internal" href="scripts.html">Scripts</a></li>
<li class="toctree-l1"><a class="reference internal" href="autodoc_source.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pybedtools</span></code> Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="changes.html">Changelog</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  <li><a href="topical-documentation-contents.html">Topical Documentation</a><ul>
      <li>Previous: <a href="topical-genome.html" title="previous chapter">Specifying genomes</a></li>
      <li>Next: <a href="topical-wrapping.html" title="next chapter">Wrapping new tools</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="topical-wrapping.html" title="Wrapping new tools"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="topical-genome.html" title="Specifying genomes"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">pybedtools 0.9.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="topical-documentation-contents.html" accesskey="U">Topical Documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Randomization</a></li> 
      </ul>
    </div>


    <div class="footer">
      &copy;2010-2015, Ryan Dale.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.3.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/topical-random.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>